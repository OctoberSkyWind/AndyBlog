"use strict";(self.webpackChunkandy_blogs=self.webpackChunkandy_blogs||[]).push([[4929],{3027:(e,a,s)=>{s.r(a),s.d(a,{comp:()=>h,data:()=>o});var t=s(2565);const r={class:"table-of-contents"},n={},h=(0,s(7459).A)(n,[["render",function(e,a){const s=(0,t.g2)("router-link");return(0,t.uX)(),(0,t.CE)("div",null,[a[6]||(a[6]=(0,t.Lk)("h1",{id:"postgresql",tabindex:"-1"},[(0,t.Lk)("a",{class:"header-anchor",href:"#postgresql"},[(0,t.Lk)("span",null,"postgresql")])],-1)),(0,t.Lk)("nav",r,[(0,t.Lk)("ul",null,[(0,t.Lk)("li",null,[(0,t.bF)(s,{to:"#数据类型"},{default:(0,t.k6)(()=>[...a[0]||(a[0]=[(0,t.eW)("数据类型",-1)])]),_:1})]),(0,t.Lk)("li",null,[(0,t.bF)(s,{to:"#索引"},{default:(0,t.k6)(()=>[...a[1]||(a[1]=[(0,t.eW)("索引",-1)])]),_:1})]),(0,t.Lk)("li",null,[(0,t.bF)(s,{to:"#全文检索"},{default:(0,t.k6)(()=>[...a[2]||(a[2]=[(0,t.eW)("全文检索",-1)])]),_:1})]),(0,t.Lk)("li",null,[(0,t.bF)(s,{to:"#并行查询"},{default:(0,t.k6)(()=>[...a[3]||(a[3]=[(0,t.eW)("并行查询",-1)])]),_:1})]),(0,t.Lk)("li",null,[(0,t.bF)(s,{to:"#规则系统"},{default:(0,t.k6)(()=>[...a[4]||(a[4]=[(0,t.eW)("规则系统",-1)])]),_:1})]),(0,t.Lk)("li",null,[(0,t.bF)(s,{to:"#pg的mvcc"},{default:(0,t.k6)(()=>[...a[5]||(a[5]=[(0,t.eW)("PG的MVCC",-1)])]),_:1})])])]),a[7]||(a[7]=(0,t.Fv)('<p>[toc]</p><h2 id="数据类型" tabindex="-1"><a class="header-anchor" href="#数据类型"><span>数据类型</span></a></h2><h4 id="tsvector-类型" tabindex="-1"><a class="header-anchor" href="#tsvector-类型"><span>tsvector 类型</span></a></h4><p>tsquery 类型</p><h2 id="索引" tabindex="-1"><a class="header-anchor" href="#索引"><span>索引</span></a></h2><h4 id="postgresql-中的" tabindex="-1"><a class="header-anchor" href="#postgresql-中的"><span>PostgreSQL 中的</span></a></h4><p><code>函数索引（也叫表达式索引）</code> 是基于列的计算结果 / 函数调用结果创建的索引，而非列本身的值，解决了 “WHERE/HAVING/ORDER BY 中使用列表达式 / 函数时普通索引失效” 的问题（是！）</p><h4 id="postgresql索引的键除了可以是一个函数外-还可以是从一个或多个字段计算出来的标量表达式-是" tabindex="-1"><a class="header-anchor" href="#postgresql索引的键除了可以是一个函数外-还可以是从一个或多个字段计算出来的标量表达式-是"><span>PostgreSQL索引的键除了可以是<code>一个函数</code>外，还可以是从一个或多个字段计算出来的<code>标量表达式</code>（是！）</span></a></h4><h4 id="pg" tabindex="-1"><a class="header-anchor" href="#pg"><span>PG</span></a></h4><p><code>函数索引适用</code>引常见场景：如 1.字段格式化、转换后的查询；2.复合表达式计算后的查询；3.空值 / 非空值的精准过滤;枚举值 / 状态的衍生计算;4.空间数据 / JSON 字段的提取查询等等（是！）</p><h4 id="pg-1" tabindex="-1"><a class="header-anchor" href="#pg-1"><span>PG</span></a></h4><p><code>函数索引不适用</code>的常见场景：1. 函数 / 表达式结果高度离散；2.函数 / 表达式结果低基数 3. 频繁更新的字段 4. 函数包含不确定 / 动态值 5. 小表，数据量极小 6. 函数 / 表达式复杂且计算成本高（是！）</p><h4 id="postgresql的部分索引是只对一个表中的部分行进行的索引-是由一个条件表达式把这部分行筛选出来-该条件表达式被称为部分索引的谓词-只对筛选出来的数据创建索引-是" tabindex="-1"><a class="header-anchor" href="#postgresql的部分索引是只对一个表中的部分行进行的索引-是由一个条件表达式把这部分行筛选出来-该条件表达式被称为部分索引的谓词-只对筛选出来的数据创建索引-是"><span>PostGreSQL的<code>部分索引是只对一个表中的部分行进行的索引</code>，是由一个条件表达式把这部分行筛选出来（该条件表达式被称为部分索引的谓词），只对筛选出来的数据创建索引（是！）</span></a></h4><h4 id="postgresql支持带任意谓词的部分索引-但是" tabindex="-1"><a class="header-anchor" href="#postgresql支持带任意谓词的部分索引-但是"><span>PostgreSQL支持带任意谓词的部分索引，但是</span></a></h4><p><code>只有在系统能够识别出该查询的WHERE条件简单地包含了该索引的谓词时，这个部分索引才能用于该查询</code>。PostgreSQL不能完全识别那些形式不同但数学上意义相等的谓词（是！）</p><h4 id="pg支持设置部分唯一索引-即全局不唯一-但是筛选条件下唯一-是" tabindex="-1"><a class="header-anchor" href="#pg支持设置部分唯一索引-即全局不唯一-但是筛选条件下唯一-是"><span>PG支持设置<code>部分唯一索引</code>，即全局不唯一，但是筛选条件下唯一（是！）</span></a></h4><h4 id="postgresql支持在任意数据类型上建立btree索引-但是btree索引只支持范围谓词-hash索引仅支持相等查询-而gist的索引还能支持包含-、重叠-等复杂运算-是" tabindex="-1"><a class="header-anchor" href="#postgresql支持在任意数据类型上建立btree索引-但是btree索引只支持范围谓词-hash索引仅支持相等查询-而gist的索引还能支持包含-、重叠-等复杂运算-是"><span>PostgreSQL支持在任意数据类型上建立BTree索引，但是BTree索引只支持范围谓词(&lt;,=, &gt;)，HASH索引仅支持相等查询，而GiST的索引还能支持包含(@&gt;)、重叠(&amp;&amp;)等复杂运算（是！）</span></a></h4><h4 id="在-postgresql-中-不指定索引类型时-默认创建的是-b-树-b-tree-索引-严格来说是-b-树的变体-postgresql-官方文档统一称-b-tree-是" tabindex="-1"><a class="header-anchor" href="#在-postgresql-中-不指定索引类型时-默认创建的是-b-树-b-tree-索引-严格来说是-b-树的变体-postgresql-官方文档统一称-b-tree-是"><span>在 PostgreSQL 中，不指定索引类型时，默认创建的是 B 树（B-tree）索引（严格来说是 B+ 树的变体，PostgreSQL 官方文档统一称 B-tree）（是！）</span></a></h4><h4 id="postgresql-的-create-index-语法中-若" tabindex="-1"><a class="header-anchor" href="#postgresql-的-create-index-语法中-若"><span>PostgreSQL 的 CREATE INDEX 语法中，若</span></a></h4><p><code>省略 USING</code> 子句指定索引类型，数据库会根据索引字段的数据类型和使用场*默认选择 B-tree 索引（是！）</p><h4 id="postgresql-显式指定创建-b-树-b-树-索引-需通过-using-btree-子句明确声明-这是最规范的写法-是" tabindex="-1"><a class="header-anchor" href="#postgresql-显式指定创建-b-树-b-树-索引-需通过-using-btree-子句明确声明-这是最规范的写法-是"><span>PostgreSQL <code>显式指定创建 B 树（B+ 树）索引，需通过 USING btree</code> 子句明确声明，这是最规范的写法(是！)</span></a></h4><h4 id="gist的索引的创建" tabindex="-1"><a class="header-anchor" href="#gist的索引的创建"><span>GiST的索引的创建</span></a></h4><h4 id="sp-gist即空间分区gist索引-通常用于多重空间-它主要是通过一些新的索引算法提高gist索引在某种情况下的性能-是" tabindex="-1"><a class="header-anchor" href="#sp-gist即空间分区gist索引-通常用于多重空间-它主要是通过一些新的索引算法提高gist索引在某种情况下的性能-是"><span><code>SP-GiST即空间分区GiST索引</code>（通常用于多重空间），它主要是通过一些新的索引算法提高GiST索引在某种情况下的性能（是！）</span></a></h4><h4 id="sp-gist索引的创建" tabindex="-1"><a class="header-anchor" href="#sp-gist索引的创建"><span>SP-GiST索引的创建</span></a></h4><h4 id="gin索引是即广义倒排索引。通常gin索引作为全文检索使用-即在文章中搜索指定的词。gin索引中存储了一系列-key-位置列表-对-位置列表中存储了包含此key值的行的列表。同一行的rowid会出现在多个位置列表中。" tabindex="-1"><a class="header-anchor" href="#gin索引是即广义倒排索引。通常gin索引作为全文检索使用-即在文章中搜索指定的词。gin索引中存储了一系列-key-位置列表-对-位置列表中存储了包含此key值的行的列表。同一行的rowid会出现在多个位置列表中。"><span>GIN索引是即广义倒排索引。通常GIN索引作为全文检索使用，即在文章中搜索指定的词。GIN索引中存储了一系列“key，位置列表”对，位置列表中存储了包含此key值的行的列表。同一行的rowid会出现在多个位置列表中。</span></a></h4><h4 id="gin索引创建" tabindex="-1"><a class="header-anchor" href="#gin索引创建"><span>GIN索引创建</span></a></h4><h4 id="gin索引可以结合-tsvector-类型使用-加快全文检索-是" tabindex="-1"><a class="header-anchor" href="#gin索引可以结合-tsvector-类型使用-加快全文检索-是"><span>GIN索引可以结合 tsvector 类型使用，加快全文检索（是！）</span></a></h4><h4 id="gin索引对于插入更新操作效率比较低-如果要向一张表中插入大量数据-最好先把gin索引删除-然后插入数据-最后再把gin索引重新建起来-把maintenance-work-mem参数调大-可以更快地完成gin索引的创建工作。-是" tabindex="-1"><a class="header-anchor" href="#gin索引对于插入更新操作效率比较低-如果要向一张表中插入大量数据-最好先把gin索引删除-然后插入数据-最后再把gin索引重新建起来-把maintenance-work-mem参数调大-可以更快地完成gin索引的创建工作。-是"><span>GIN索引对于插入更新操作效率比较低，如果要向一张表中插入大量数据，最好先把GIN索引删除，然后插入数据，最后再把GIN索引重新建起来，把maintenance_work_mem参数调大，可以更快地完成GIN索引的创建工作。（是）</span></a></h4><h4 id="brin索引-todo" tabindex="-1"><a class="header-anchor" href="#brin索引-todo"><span>BRIN索引(<code>todo！</code>)</span></a></h4><h2 id="全文检索" tabindex="-1"><a class="header-anchor" href="#全文检索"><span>全文检索</span></a></h2><h4 id="postgresql内置了全文检索功能-但内置的功能只能检索英文。当然-配置一些插件如-zhparser-也可以对中文进行全文检索-是" tabindex="-1"><a class="header-anchor" href="#postgresql内置了全文检索功能-但内置的功能只能检索英文。当然-配置一些插件如-zhparser-也可以对中文进行全文检索-是"><span>PostgreSQL内置了全文检索功能，但内置的功能只能检索英文。当然，配置一些插件如 zhparser 也可以对中文进行全文检索(是)</span></a></h4><h4 id="安装-zhparser-插件实现中文检索-todo" tabindex="-1"><a class="header-anchor" href="#安装-zhparser-插件实现中文检索-todo"><span>安装 zhparser 插件实现中文检索（<code>todo!</code>）</span></a></h4><h4 id="安装-pg-jieba-分词插件-实现中文检索-todo" tabindex="-1"><a class="header-anchor" href="#安装-pg-jieba-分词插件-实现中文检索-todo"><span>安装 pg_jieba 分词插件 实现中文检索（<code>todo!</code>）</span></a></h4><h4 id="g-jieba-对中文的支持显著优于-zhparser——-尤其是在分词精度、功能丰富度、自定义能力等核心维度-pg-jieba-是-postgresql-生态中目前最优的中文分词扩展之一-是" tabindex="-1"><a class="header-anchor" href="#g-jieba-对中文的支持显著优于-zhparser——-尤其是在分词精度、功能丰富度、自定义能力等核心维度-pg-jieba-是-postgresql-生态中目前最优的中文分词扩展之一-是"><span>g_jieba 对中文的支持显著优于 zhparser—— 尤其是在分词精度、功能丰富度、自定义能力等核心维度，pg_jieba 是 PostgreSQL 生态中目前最优的中文分词扩展之一（是！）</span></a></h4><h4 id="postgresql把长文本分解成很多token的集合-这个token集合叫tsvector-代表了文档-搜索实际上是在token集合中进行的" tabindex="-1"><a class="header-anchor" href="#postgresql把长文本分解成很多token的集合-这个token集合叫tsvector-代表了文档-搜索实际上是在token集合中进行的"><span>PostgreSQL把长文本分解成很多token的集合，这个token集合叫tsvector，代表了文档，搜索实际上是在token集合中进行的</span></a></h4><h4 id="to-tsvector-是-postgresql-中核心的全文检索函数-用于将普通文本-text-类型-转换为优化后的-tsvector-类型数据-是" tabindex="-1"><a class="header-anchor" href="#to-tsvector-是-postgresql-中核心的全文检索函数-用于将普通文本-text-类型-转换为优化后的-tsvector-类型数据-是"><span><code>to_tsvector </code>是 PostgreSQL 中核心的全文检索函数，用于将普通文本（text 类型）转换为优化后的 tsvector 类型数据（是！）</span></a></h4><h4 id="postgresql增加了一个检索条件的类型-tsquery-tsquery是一个由简单逻辑运行符号组成的字符串-postgresql也提供了函数-to-tsquery-来实现这个转换-是" tabindex="-1"><a class="header-anchor" href="#postgresql增加了一个检索条件的类型-tsquery-tsquery是一个由简单逻辑运行符号组成的字符串-postgresql也提供了函数-to-tsquery-来实现这个转换-是"><span>PostgreSQL增加了一个检索条件的类型“tsquery”，tsquery是一个由简单逻辑运行符号组成的字符串，PostgreSQL也提供了函数“to_tsquery”来实现这个转换（是！）</span></a></h4><h4 id="postgresql全文检索的搜索过程实际上使用一个tsvector和tsquery进行匹配-tsvector代表了文档-而tsquery代表了检索条件-匹配的运算符是-是" tabindex="-1"><a class="header-anchor" href="#postgresql全文检索的搜索过程实际上使用一个tsvector和tsquery进行匹配-tsvector代表了文档-而tsquery代表了检索条件-匹配的运算符是-是"><span>PostgreSQL全文检索的搜索过程实际上使用一个tsvector和tsquery进行匹配，tsvector代表了文档，而tsquery代表了检索条件，匹配的运算符是&quot;@@&quot;（是！）</span></a></h4><h4 id="基于tsvector做全文检索时一般都要结合gin索引加快扫描-是" tabindex="-1"><a class="header-anchor" href="#基于tsvector做全文检索时一般都要结合gin索引加快扫描-是"><span>基于tsvector做全文检索时一般都要结合GIN索引加快扫描（是！）</span></a></h4><h2 id="并行查询" tabindex="-1"><a class="header-anchor" href="#并行查询"><span>并行查询</span></a></h2><h4 id="postgresql并行查询相关的配置参数" tabindex="-1"><a class="header-anchor" href="#postgresql并行查询相关的配置参数"><span>PostgreSQL并行查询相关的配置参数</span></a></h4><h4 id="postgresql支持的并行操作" tabindex="-1"><a class="header-anchor" href="#postgresql支持的并行操作"><span>PostgreSQL支持的并行操作</span></a></h4><h2 id="规则系统" tabindex="-1"><a class="header-anchor" href="#规则系统"><span>规则系统</span></a></h2><h4 id="postgresql的视图是通过select规则来实现的-是" tabindex="-1"><a class="header-anchor" href="#postgresql的视图是通过select规则来实现的-是"><span>PostgreSQL的视图是通过SELECT规则来实现的(是！)</span></a></h4><h4 id="select规则的后续动作只能是instead-select-即只能用另一个select语句取代-是" tabindex="-1"><a class="header-anchor" href="#select规则的后续动作只能是instead-select-即只能用另一个select语句取代-是"><span>SELECT规则的后续动作只能是INSTEAD SELECT，即只能用另一个SELECT语句取代（是！）</span></a></h4><h4 id="select规则的名称只能是-return" tabindex="-1"><a class="header-anchor" href="#select规则的名称只能是-return"><span>SELECT规则的名称只能是“_RETURN”</span></a></h4><h4 id="创建规则的-语法" tabindex="-1"><a class="header-anchor" href="#创建规则的-语法"><span>创建规则的 语法</span></a></h4><h4 id="规则-rule-是从属于表或视图的。如果一张表属于一个用户-则这张表上的所有规则都是属于这个用户的。在规则系统中检测权限时-是对规则的属主进行权限检查-而不是执行规则的用户-是" tabindex="-1"><a class="header-anchor" href="#规则-rule-是从属于表或视图的。如果一张表属于一个用户-则这张表上的所有规则都是属于这个用户的。在规则系统中检测权限时-是对规则的属主进行权限检查-而不是执行规则的用户-是"><span>规则(RULE)是从属于表或视图的。如果一张表属于一个用户，则这张表上的所有规则都是属于这个用户的。在规则系统中检测权限时，是对规则的属主进行权限检查，而不是执行规则的用户(是)</span></a></h4><h4 id="触发器能做的很多事情使用postgresql的规则系统也可以完成-使用哪种方法取决于具体的应用场景。规则系统是通过查询重写来实现的-而触发器通常是为每个行都触发执行一次-所以对于批量操作-使用规则可能会生成更好的执行计划-从而效率更高一些。是" tabindex="-1"><a class="header-anchor" href="#触发器能做的很多事情使用postgresql的规则系统也可以完成-使用哪种方法取决于具体的应用场景。规则系统是通过查询重写来实现的-而触发器通常是为每个行都触发执行一次-所以对于批量操作-使用规则可能会生成更好的执行计划-从而效率更高一些。是"><span>触发器能做的很多事情使用PostgreSQL的规则系统也可以完成，使用哪种方法取决于具体的应用场景。规则系统是通过查询重写来实现的，而触发器通常是为每个行都触发执行一次，所以对于批量操作，使用规则可能会生成更好的执行计划，从而效率更高一些。是）</span></a></h4><h4 id="触发器和规则选型和适用-todo" tabindex="-1"><a class="header-anchor" href="#触发器和规则选型和适用-todo"><span>触发器和规则选型和适用（<code>todo！</code>）</span></a></h4><h2 id="pg的mvcc" tabindex="-1"><a class="header-anchor" href="#pg的mvcc"><span>PG的MVCC</span></a></h2>',51))])}]]),o=JSON.parse('{"path":"/andy-interview-and-outline/data-storage/postgresql.html","title":"postgresql","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"数据类型","slug":"数据类型","link":"#数据类型","children":[]},{"level":2,"title":"索引","slug":"索引","link":"#索引","children":[]},{"level":2,"title":"全文检索","slug":"全文检索","link":"#全文检索","children":[]},{"level":2,"title":"并行查询","slug":"并行查询","link":"#并行查询","children":[]},{"level":2,"title":"规则系统","slug":"规则系统","link":"#规则系统","children":[]},{"level":2,"title":"PG的MVCC","slug":"pg的mvcc","link":"#pg的mvcc","children":[]}],"git":{"updatedTime":1766221301000,"contributors":[{"name":"xiang.han","username":"","email":"839462320@qq.com","commits":5},{"name":"WhaleFall","username":"WhaleFall","email":"839462320@qq.com","commits":1,"url":"https://github.com/WhaleFall"}],"changelog":[{"hash":"c971c9e60655c44a4c6a51f35c300f6f682acb97","time":1766221301000,"email":"839462320@qq.com","author":"xiang.han","message":"2025/12/20 17:01:40"},{"hash":"2ace183ccc870716cf3dc053a4aa3e935759d9de","time":1765605982000,"email":"839462320@qq.com","author":"WhaleFall","message":"2025-12-13 14:06:21"},{"hash":"fc6ee4346ac2dcd2f4c159cc397847837de218a2","time":1764080234000,"email":"839462320@qq.com","author":"xiang.han","message":"2025/11/25 20:39:12"},{"hash":"3b1c1fd1d8941857fdb6fb7d3b64812257ce1179","time":1764074353000,"email":"839462320@qq.com","author":"xiang.han","message":"2025/11/25 20:39:12"},{"hash":"bfa27a37fcb0a0df6cf9ea189e8d2589f86c46b3","time":1764069171000,"email":"839462320@qq.com","author":"xiang.han","message":"2025/11/25 19:12:09"},{"hash":"ac04b42831007bb1f3be9cf8e49a3d44f1de2b37","time":1764069131000,"email":"839462320@qq.com","author":"xiang.han","message":"2025/11/25 19:12:09"}]},"filePathRelative":"andy-interview-and-outline/data-storage/postgresql.md","excerpt":"\\n\\n<p>[toc]</p>\\n<h2>数据类型</h2>\\n<h4>tsvector 类型</h4>\\n<p>tsquery 类型</p>\\n<h2>索引</h2>\\n<h4>PostgreSQL 中的</h4>\\n<p><code>函数索引（也叫表达式索引）</code> 是基于列的计算结果 / 函数调用结果创建的索引，而非列本身的值，解决了 “WHERE/HAVING/ORDER BY 中使用列表达式 / 函数时普通索引失效” 的问题（是！）</p>\\n<h4>PostgreSQL索引的键除了可以是<code>一个函数</code>外，还可以是从一个或多个字段计算出来的<code>标量表达式</code>（是！）</h4>"}')}}]);