"use strict";(self.webpackChunkandy_blogs=self.webpackChunkandy_blogs||[]).push([[458],{7667:(a,e,s)=>{s.r(e),s.d(e,{comp:()=>i,data:()=>l});var h=s(2565);const n={class:"table-of-contents"},r={id:"内置组件之component-在上通过的is属性指定-可以实现动态切换组件",tabindex:"-1"},d={class:"header-anchor",href:"#内置组件之component-在上通过的is属性指定-可以实现动态切换组件"},t={},i=(0,s(7459).A)(t,[["render",function(a,e){const s=(0,h.g2)("router-link"),t=(0,h.g2)("component");return(0,h.uX)(),(0,h.CE)("div",null,[e[7]||(e[7]=(0,h.Lk)("h1",{id:"vue3",tabindex:"-1"},[(0,h.Lk)("a",{class:"header-anchor",href:"#vue3"},[(0,h.Lk)("span",null,"Vue3")])],-1)),e[8]||(e[8]=(0,h.Lk)("p",null,"[TOC]",-1)),(0,h.Lk)("nav",n,[(0,h.Lk)("ul",null,[(0,h.Lk)("li",null,[(0,h.bF)(s,{to:"#组合式-api"},{default:(0,h.k6)(()=>[...e[0]||(e[0]=[(0,h.eW)("组合式 API",-1)])]),_:1})]),(0,h.Lk)("li",null,[(0,h.bF)(s,{to:"#样式"},{default:(0,h.k6)(()=>[...e[1]||(e[1]=[(0,h.eW)("样式",-1)])]),_:1})]),(0,h.Lk)("li",null,[(0,h.bF)(s,{to:"#组件"},{default:(0,h.k6)(()=>[...e[2]||(e[2]=[(0,h.eW)("组件",-1)])]),_:1})]),(0,h.Lk)("li",null,[(0,h.bF)(s,{to:"#路由"},{default:(0,h.k6)(()=>[...e[3]||(e[3]=[(0,h.eW)("路由",-1)])]),_:1})]),(0,h.Lk)("li",null,[(0,h.bF)(s,{to:"#数据请求"},{default:(0,h.k6)(()=>[...e[4]||(e[4]=[(0,h.eW)("数据请求",-1)])]),_:1})])])]),e[9]||(e[9]=(0,h.Fv)('<h2 id="组合式-api" tabindex="-1"><a class="header-anchor" href="#组合式-api"><span>组合式 API</span></a></h2><h4 id="setup组合式api入口函数" tabindex="-1"><a class="header-anchor" href="#setup组合式api入口函数"><span>setup组合式API入口函数</span></a></h4><h4 id="ref函数定义响应式数据" tabindex="-1"><a class="header-anchor" href="#ref函数定义响应式数据"><span>ref函数定义响应式数据</span></a></h4><h4 id="torefs与toref函数" tabindex="-1"><a class="header-anchor" href="#torefs与toref函数"><span>toRefs与toRef函数</span></a></h4><h4 id="readonly与shallowreadonly函数" tabindex="-1"><a class="header-anchor" href="#readonly与shallowreadonly函数"><span>readonly与shallowReadonly函数</span></a></h4><h4 id="shallowref与shallowreactive函数" tabindex="-1"><a class="header-anchor" href="#shallowref与shallowreactive函数"><span>shallowRef与shallowReactive函数</span></a></h4><h4 id="toraw与markraw函数" tabindex="-1"><a class="header-anchor" href="#toraw与markraw函数"><span>toRaw与markRaw函数</span></a></h4><h4 id="computed函数" tabindex="-1"><a class="header-anchor" href="#computed函数"><span>computed函数</span></a></h4><h4 id="watch函数" tabindex="-1"><a class="header-anchor" href="#watch函数"><span>watch函数</span></a></h4><h4 id="生命周期函数" tabindex="-1"><a class="header-anchor" href="#生命周期函数"><span>生命周期函数</span></a></h4><h2 id="样式" tabindex="-1"><a class="header-anchor" href="#样式"><span>样式</span></a></h2><h4 id="组件作用域-css" tabindex="-1"><a class="header-anchor" href="#组件作用域-css"><span>组件作用域 CSS</span></a></h4><h4 id="css-modules" tabindex="-1"><a class="header-anchor" href="#css-modules"><span>CSS Modules</span></a></h4><h4 id="css-中的-v-bind" tabindex="-1"><a class="header-anchor" href="#css-中的-v-bind"><span>CSS 中的 v-bind()</span></a></h4><h2 id="组件" tabindex="-1"><a class="header-anchor" href="#组件"><span>组件</span></a></h2><h4 id="父与子通信之props————简单数组接收-简单对象接收-复杂对象接收" tabindex="-1"><a class="header-anchor" href="#父与子通信之props————简单数组接收-简单对象接收-复杂对象接收"><span>父与子通信之props————简单数组接收，简单对象接收，复杂对象接收</span></a></h4><h4 id="组件通信之ref与defineexpose-通过触发事件" tabindex="-1"><a class="header-anchor" href="#组件通信之ref与defineexpose-通过触发事件"><span>组件通信之ref与defineExpose（通过触发事件）</span></a></h4><h4 id="组件通信之attrs-非prop属性透传-获取父组件传递给子组件、但子组件未在-props-或-emits-中声明的所有属性和事件" tabindex="-1"><a class="header-anchor" href="#组件通信之attrs-非prop属性透传-获取父组件传递给子组件、但子组件未在-props-或-emits-中声明的所有属性和事件"><span>组件通信之attrs（非Prop属性透传，获取父组件传递给子组件、但子组件未在 props 或 emits 中声明的所有属性和事件）</span></a></h4><ul><li>vue3父组件的class 和 style，这两个属性会自动合并到子组件的根元素 <ul><li>class：父组件的类名与子组件根元素的类名会合并（去重），不会覆盖（优先级由 CSS 规则决定）。</li><li>style：父组件的内联样式与子组件根元素的内联样式会合并，若存在相同 CSS 属性，父组件的样式会覆盖子组件（遵循 “后定义覆盖先定义”+ 父透传优先级更高）。</li></ul></li><li>Vue 3 推荐通过 useAttrs() 函数获取 attrs 对象，不可直接解构（会丢失响应式），需通过 toRefs 或直接访问</li><li>父组件通过 v-on 传递的事件，会自动被 attrs 收集并支持透传—— 本质是：v-on:xxx 会被转化为 attrs 中的 onXxx （驼峰命名）属性，通过 v-bind=&quot;$attrs&quot; 可直接透传给子组件内部元素，无需额外处理。</li></ul><h4 id="组件通信之provide与inject-跨层级组件通信" tabindex="-1"><a class="header-anchor" href="#组件通信之provide与inject-跨层级组件通信"><span>组件通信之provide与inject（跨层级组件通信）</span></a></h4><h4 id="组件通信之mitt-第三方类库-基于发布-订阅模式" tabindex="-1"><a class="header-anchor" href="#组件通信之mitt-第三方类库-基于发布-订阅模式"><span>组件通信之mitt（第三方类库），基于发布-订阅模式</span></a></h4><h4 id="组件通信之slot-默认插槽-具名插槽-插槽默认值-作用域插槽" tabindex="-1"><a class="header-anchor" href="#组件通信之slot-默认插槽-具名插槽-插槽默认值-作用域插槽"><span>组件通信之slot（默认插槽，具名插槽，插槽默认值，作用域插槽）</span></a></h4>',22)),(0,h.Lk)("h4",r,[(0,h.Lk)("a",d,[(0,h.Lk)("span",null,[e[5]||(e[5]=(0,h.eW)("内置组件之Component（在",-1)),(0,h.bF)(t),e[6]||(e[6]=(0,h.eW)("上通过的is属性指定，可以实现动态切换组件）",-1))])])]),e[10]||(e[10]=(0,h.Fv)('<h4 id="内置组件之keepalive-缓存组件" tabindex="-1"><a class="header-anchor" href="#内置组件之keepalive-缓存组件"><span>内置组件之KeepAlive（缓存组件）</span></a></h4><h4 id="内置组件之teleport-实现将一个组件内部的一部分模板-传送-到该组件的-dom-结构外层的位置" tabindex="-1"><a class="header-anchor" href="#内置组件之teleport-实现将一个组件内部的一部分模板-传送-到该组件的-dom-结构外层的位置"><span>内置组件之Teleport(实现将一个组件内部的一部分模板“传送”到该组件的 DOM 结构外层的位置)</span></a></h4><h4 id="代码封装之自定义directive-指令-自定义指令" tabindex="-1"><a class="header-anchor" href="#代码封装之自定义directive-指令-自定义指令"><span>代码封装之自定义directive（指令,自定义指令）</span></a></h4><h4 id="代码封装之自定义hook-钩子" tabindex="-1"><a class="header-anchor" href="#代码封装之自定义hook-钩子"><span>代码封装之自定义hook（钩子，）</span></a></h4><h4 id="代码封装之plugin-插件-todo-study" tabindex="-1"><a class="header-anchor" href="#代码封装之plugin-插件-todo-study"><span>代码封装之plugin（插件）（todo study）</span></a></h4><h2 id="路由" tabindex="-1"><a class="header-anchor" href="#路由"><span>路由</span></a></h2><h4 id="router-view-是路由的出口-路由出口匹配规则-一级路由找-app-vue-根出口-子路由找父组件内最近的子出口-无则失败" tabindex="-1"><a class="header-anchor" href="#router-view-是路由的出口-路由出口匹配规则-一级路由找-app-vue-根出口-子路由找父组件内最近的子出口-无则失败"><span>router-view 是路由的出口,路由出口匹配规则：一级路由找 App.vue 根出口，子路由找父组件内最近的子出口（无则失败);</span></a></h4><h4 id="当页渲染的一般核心方案-1-框架不变、内容切换-→-用「嵌套路由」-2-同一组件、不同参数-→-用「动态路由匹配-参数监听」-3-url-不变、刷新内容-→-直接重新请求数据-或强制刷新组件" tabindex="-1"><a class="header-anchor" href="#当页渲染的一般核心方案-1-框架不变、内容切换-→-用「嵌套路由」-2-同一组件、不同参数-→-用「动态路由匹配-参数监听」-3-url-不变、刷新内容-→-直接重新请求数据-或强制刷新组件"><span>当页渲染的一般核心方案：1.框架不变、内容切换 → 用「嵌套路由」；2.同一组件、不同参数 → 用「动态路由匹配 + 参数监听」；3.URL 不变、刷新内容 → 直接重新请求数据（或强制刷新组件）</span></a></h4><h4 id="router-link是声明式路由导航-本质上是a标签" tabindex="-1"><a class="header-anchor" href="#router-link是声明式路由导航-本质上是a标签"><span>router-link是声明式路由导航，本质上是a标签</span></a></h4><h4 id="路由链接高亮显示-to-study" tabindex="-1"><a class="header-anchor" href="#路由链接高亮显示-to-study"><span>路由链接高亮显示（to study）</span></a></h4><h4 id="vue-router模块的参数做一个简单总结-它主要分成params与query两种参数类型-params参数的设参在路由部分-传参在链接部分-接参和用参在组件部分-query参数的设参和传参在链接部分-接参和用参在组件部分-xxx" tabindex="-1"><a class="header-anchor" href="#vue-router模块的参数做一个简单总结-它主要分成params与query两种参数类型-params参数的设参在路由部分-传参在链接部分-接参和用参在组件部分-query参数的设参和传参在链接部分-接参和用参在组件部分-xxx"><span>vue-router模块的参数做一个简单总结：它主要分成params与query两种参数类型，params参数的设参在路由部分，传参在链接部分，接参和用参在组件部分；query参数的设参和传参在链接部分，接参和用参在组件部分（”：xxx“）</span></a></h4><h4 id="基于params参数路由高亮显示-to-study" tabindex="-1"><a class="header-anchor" href="#基于params参数路由高亮显示-to-study"><span>基于params参数路由高亮显示（to study）</span></a></h4><h4 id="基于props的不同类型映射" tabindex="-1"><a class="header-anchor" href="#基于props的不同类型映射"><span>基于props的不同类型映射</span></a></h4><h4 id="命名路由切换" tabindex="-1"><a class="header-anchor" href="#命名路由切换"><span>命名路由切换</span></a></h4><h4 id="命名视图渲染" tabindex="-1"><a class="header-anchor" href="#命名视图渲染"><span>命名视图渲染</span></a></h4><h4 id="利用命名视图控制头部-底部内容在后续进行代码修改操作时-只需要集中在路由表的配置上就可以了-操作位置单一、可维护性强-支持嵌套" tabindex="-1"><a class="header-anchor" href="#利用命名视图控制头部-底部内容在后续进行代码修改操作时-只需要集中在路由表的配置上就可以了-操作位置单一、可维护性强-支持嵌套"><span>利用命名视图控制头部/底部内容在后续进行代码修改操作时，只需要集中在路由表的配置上就可以了，操作位置单一、可维护性强（支持嵌套）</span></a></h4><h4 id="编程式路由导航" tabindex="-1"><a class="header-anchor" href="#编程式路由导航"><span>编程式路由导航</span></a></h4><h4 id="路由重定向" tabindex="-1"><a class="header-anchor" href="#路由重定向"><span>路由重定向</span></a></h4><h4 id="模糊匹配路由-可以通过-xxx-再加模糊匹配从而捕获访问不存在的路由-由结合重定向实现自动跳转错误页面" tabindex="-1"><a class="header-anchor" href="#模糊匹配路由-可以通过-xxx-再加模糊匹配从而捕获访问不存在的路由-由结合重定向实现自动跳转错误页面"><span>模糊匹配路由（可以通过：xxx 再加模糊匹配从而捕获访问不存在的路由）由结合重定向实现自动跳转错误页面</span></a></h4><h4 id="路由过渡动画效果-to-study" tabindex="-1"><a class="header-anchor" href="#路由过渡动画效果-to-study"><span>路由过渡动画效果（to study）</span></a></h4><h4 id="路由滚动行为-to-study" tabindex="-1"><a class="header-anchor" href="#路由滚动行为-to-study"><span>路由滚动行为（to study）</span></a></h4><h4 id="路由的异步懒加载" tabindex="-1"><a class="header-anchor" href="#路由的异步懒加载"><span>路由的异步懒加载</span></a></h4><h4 id="缓存路由组件-to-study" tabindex="-1"><a class="header-anchor" href="#缓存路由组件-to-study"><span>缓存路由组件(to study）</span></a></h4><h4 id="路由守卫-全局前置守卫-全局解析守卫-全局后置守卫-独享守卫-路由组件内守卫" tabindex="-1"><a class="header-anchor" href="#路由守卫-全局前置守卫-全局解析守卫-全局后置守卫-独享守卫-路由组件内守卫"><span>路由守卫（全局前置守卫，全局解析守卫，全局后置守卫，独享守卫，路由组件内守卫）</span></a></h4><h4 id="基于路由守卫和进度条模块实现-页面切换时进度条的显示与隐藏控制" tabindex="-1"><a class="header-anchor" href="#基于路由守卫和进度条模块实现-页面切换时进度条的显示与隐藏控制"><span>基于路由守卫和进度条模块实现 页面切换时进度条的显示与隐藏控制</span></a></h4><h4 id="路由全局守卫实现授权页面的禁用与指定页面的查看功能" tabindex="-1"><a class="header-anchor" href="#路由全局守卫实现授权页面的禁用与指定页面的查看功能"><span>路由全局守卫实现授权页面的禁用与指定页面的查看功能</span></a></h4><h4 id="路由组件的钩子函数" tabindex="-1"><a class="header-anchor" href="#路由组件的钩子函数"><span>路由组件的钩子函数</span></a></h4><h4 id="动态添加与删除路由" tabindex="-1"><a class="header-anchor" href="#动态添加与删除路由"><span>动态添加与删除路由</span></a></h4><h2 id="数据请求" tabindex="-1"><a class="header-anchor" href="#数据请求"><span>数据请求</span></a></h2>',29))])}]]),l=JSON.parse('{"path":"/interviewAndOutline/Vue3.html","title":"Vue3","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"组合式 API","slug":"组合式-api","link":"#组合式-api","children":[]},{"level":2,"title":"样式","slug":"样式","link":"#样式","children":[]},{"level":2,"title":"组件","slug":"组件","link":"#组件","children":[]},{"level":2,"title":"路由","slug":"路由","link":"#路由","children":[]},{"level":2,"title":"数据请求","slug":"数据请求","link":"#数据请求","children":[]}],"git":{"updatedTime":1764775150000,"contributors":[{"name":"xiang.han","username":"","email":"839462320@qq.com","commits":10}],"changelog":[{"hash":"f8cdbfc565bf12efb629515e592d780d93329044","time":1764775150000,"email":"839462320@qq.com","author":"xiang.han","message":"2025/12/03 23:19:08"},{"hash":"a7ba1493e03a5607254a96eadb6fb230cba15534","time":1764773990000,"email":"839462320@qq.com","author":"xiang.han","message":"2025/12/03 22:59:49"},{"hash":"458e84b5b36dd059d813a5369b29f62d0af8d6c7","time":1764773528000,"email":"839462320@qq.com","author":"xiang.han","message":"2025/12/03 22:52:06"},{"hash":"3351a6cbd23a7bfa62f8eed7359698bd9015c31c","time":1764688519000,"email":"839462320@qq.com","author":"xiang.han","message":"2025/12/02 23:15:18"},{"hash":"d2093fefeb67c680b6f00ba1c849929d2f97b65d","time":1764682305000,"email":"839462320@qq.com","author":"xiang.han","message":"2025/12/02 21:31:43"},{"hash":"63c624ff7ae8f94d3d006d7ec6a1ed650dab9a28","time":1764678824000,"email":"839462320@qq.com","author":"xiang.han","message":"2025/12/02 20:33:42"},{"hash":"a6c5a15b997e59b32f42576d7070b4d3e03e972f","time":1764677222000,"email":"839462320@qq.com","author":"xiang.han","message":"2025/12/02 07:46:42"},{"hash":"c2681d10201e725e59e4cf5e5ba7258ad464f7e3","time":1764677132000,"email":"839462320@qq.com","author":"xiang.han","message":"2025/12/02 07:46:42"},{"hash":"d094a14a8b000de42a01b36765458f1eff3a10c9","time":1764632804000,"email":"839462320@qq.com","author":"xiang.han","message":"2025/12/02 07:46:42"},{"hash":"37cd5f2385f229181e94b4494b345adcd50fa2a0","time":1764595658000,"email":"839462320@qq.com","author":"xiang.han","message":"2025/12/01 21:27:37"}]},"filePathRelative":"interviewAndOutline/Vue3.md","excerpt":"\\n<p>[TOC]</p>\\n\\n<h2>组合式 API</h2>\\n<h4>setup组合式API入口函数</h4>\\n<h4>ref函数定义响应式数据</h4>\\n<h4>toRefs与toRef函数</h4>\\n<h4>readonly与shallowReadonly函数</h4>\\n<h4>shallowRef与shallowReactive函数</h4>\\n<h4>toRaw与markRaw函数</h4>\\n<h4>computed函数</h4>\\n<h4>watch函数</h4>\\n<h4>生命周期函数</h4>\\n<h2>样式</h2>\\n<h4>组件作用域 CSS</h4>\\n<h4>CSS Modules</h4>"}')}}]);