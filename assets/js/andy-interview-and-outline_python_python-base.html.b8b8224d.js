"use strict";(self.webpackChunkandy_blogs=self.webpackChunkandy_blogs||[]).push([[977],{7585:(a,n,e)=>{e.r(n),e.d(n,{comp:()=>i,data:()=>l});var s=e(2565);const t={},i=(0,e(7459).A)(t,[["render",function(a,n){return(0,s.uX)(),(0,s.CE)("div",null,[...n[0]||(n[0]=[(0,s.Fv)('<h1 id="python-base" tabindex="-1"><a class="header-anchor" href="#python-base"><span>Python Base</span></a></h1><h2 id="python-env" tabindex="-1"><a class="header-anchor" href="#python-env"><span>Python ENV</span></a></h2><h4 id="pip-pip-安装-requirements-txt-依赖-pip-install-r-requirements-txt" tabindex="-1"><a class="header-anchor" href="#pip-pip-安装-requirements-txt-依赖-pip-install-r-requirements-txt"><span>pip::pip 安装 requirements.txt 依赖： pip install -r requirements.txt</span></a></h4><h4 id="conda-conda关闭默认base激活" tabindex="-1"><a class="header-anchor" href="#conda-conda关闭默认base激活"><span>conda::conda关闭默认base激活</span></a></h4><h4 id="uv-uv创建虚拟环境" tabindex="-1"><a class="header-anchor" href="#uv-uv创建虚拟环境"><span>uv::uv创建虚拟环境</span></a></h4><h4 id="uv-windows下激活指定位置nv环境-powershell终端执行-安装目录-script-activate-ps1" tabindex="-1"><a class="header-anchor" href="#uv-windows下激活指定位置nv环境-powershell终端执行-安装目录-script-activate-ps1"><span>uv::windows下激活指定位置nv环境,powershell终端执行 安装目录\\Script\\Activate.ps1</span></a></h4><h4 id="uv-windows下激活指定位置nv环境cmdl终端执行-安装目录-script-activate-bat" tabindex="-1"><a class="header-anchor" href="#uv-windows下激活指定位置nv环境cmdl终端执行-安装目录-script-activate-bat"><span>uv::windows下激活指定位置nv环境cmdl终端执行 安装目录\\Script\\Activate.bat</span></a></h4><h2 id="python-数据类型" tabindex="-1"><a class="header-anchor" href="#python-数据类型"><span>python 数据类型</span></a></h2><h4 id="int类型-python-3-中整数类型只有-int-它支持任意精度-可表示极大整数-其取值范围受系统内存-物理内存-虚拟内存-限制。" tabindex="-1"><a class="header-anchor" href="#int类型-python-3-中整数类型只有-int-它支持任意精度-可表示极大整数-其取值范围受系统内存-物理内存-虚拟内存-限制。"><span>int类型：Python 3 中整数类型只有 int，它支持任意精度，可表示极大整数，其取值范围受系统内存（物理内存 + 虚拟内存）限制。</span></a></h4><h2 id="" tabindex="-1"><a class="header-anchor" href="#"><span></span></a></h2><h4 id="python-中的相对路径主要是相对于程序的当前工作目录-cwd-当前工作目录是-python-解释器在运行时所处的目录-load-dotenv-env-加载时-是指的当前工作目录下的-env文件" tabindex="-1"><a class="header-anchor" href="#python-中的相对路径主要是相对于程序的当前工作目录-cwd-当前工作目录是-python-解释器在运行时所处的目录-load-dotenv-env-加载时-是指的当前工作目录下的-env文件"><span>Python 中的相对路径主要是相对于程序的当前工作目录（CWD),当前工作目录是 Python 解释器在运行时所处的目录,load_dotenv(&quot;./.env&quot;)加载时，是指的当前工作目录下的.env文件</span></a></h4><h4 id="is-运算符用于判断两个变量是否指向内存中的同一个对象-即身份相同-本质是比较两个对象的-id-返回值是否相等-该运算符仅关注对象的内存地址-不涉及值的比较-即便两个对象的值完全一致但内存地址不同-is-也会返回-false-而-isinstance-函数用于判断一个对象是否是指定类-或其子类-的实例-即类型匹配-天然支持继承关系-isinstance-的第二个参数不仅可以是单个类-还可以是由多个类-或抽象基类-组成的元组-用于检查对象是否为元组中任意一个类-或抽象基类-的实例-该函数仅关注对象的类型层级关系-不涉及内存地址的比较。" tabindex="-1"><a class="header-anchor" href="#is-运算符用于判断两个变量是否指向内存中的同一个对象-即身份相同-本质是比较两个对象的-id-返回值是否相等-该运算符仅关注对象的内存地址-不涉及值的比较-即便两个对象的值完全一致但内存地址不同-is-也会返回-false-而-isinstance-函数用于判断一个对象是否是指定类-或其子类-的实例-即类型匹配-天然支持继承关系-isinstance-的第二个参数不仅可以是单个类-还可以是由多个类-或抽象基类-组成的元组-用于检查对象是否为元组中任意一个类-或抽象基类-的实例-该函数仅关注对象的类型层级关系-不涉及内存地址的比较。"><span>is 运算符用于判断两个变量是否指向内存中的同一个对象（即身份相同，本质是比较两个对象的 id() 返回值是否相等），该运算符仅关注对象的内存地址，不涉及值的比较，即便两个对象的值完全一致但内存地址不同，is 也会返回 False；而 isinstance() 函数用于判断一个对象是否是指定类（或其子类）的实例（即类型匹配，天然支持继承关系），isinstance() 的第二个参数不仅可以是单个类，还可以是由多个类（或抽象基类）组成的元组，用于检查对象是否为元组中任意一个类（或抽象基类）的实例，该函数仅关注对象的类型层级关系，不涉及内存地址的比较。</span></a></h4><h4 id="对于可变对象-调用原地修改方法实现对象内容的原地更新-变量地址保持不变-而-a-a-2-会先计算生成新对象-再将变量重新指向新对象-地址发生改变-对于不可变对象-因无原地修改能力-会退化为与-a-a-2-相同的逻辑-均创建新对象-仅元组因-python-底层优化-空-单元素元组的-会呈现地址不变的表象-不改变不可变对象的核心特性。" tabindex="-1"><a class="header-anchor" href="#对于可变对象-调用原地修改方法实现对象内容的原地更新-变量地址保持不变-而-a-a-2-会先计算生成新对象-再将变量重新指向新对象-地址发生改变-对于不可变对象-因无原地修改能力-会退化为与-a-a-2-相同的逻辑-均创建新对象-仅元组因-python-底层优化-空-单元素元组的-会呈现地址不变的表象-不改变不可变对象的核心特性。"><span>对于可变对象，<em>= 调用原地修改方法实现对象内容的原地更新，变量地址保持不变，而 a = a * 2 会先计算生成新对象，再将变量重新指向新对象，地址发生改变；对于不可变对象，因无原地修改能力，</em>= 会退化为与 a = a * 2 相同的逻辑（均创建新对象），仅元组因 Python 底层优化，空 / 单元素元组的*=会呈现地址不变的表象，不改变不可变对象的核心特性。</span></a></h4><h2 id="python-函数" tabindex="-1"><a class="header-anchor" href="#python-函数"><span>python 函数</span></a></h2><h4 id="print-有-5-个主要参数-其中第一个-objects-是可变参数" tabindex="-1"><a class="header-anchor" href="#print-有-5-个主要参数-其中第一个-objects-是可变参数"><span>print() 有 5 个主要参数，其中第一个 *objects 是可变参数</span></a></h4><h4 id="print-函数默认使用空格分隔多个参数-但可以通过-sep-参数自定义分隔符" tabindex="-1"><a class="header-anchor" href="#print-函数默认使用空格分隔多个参数-但可以通过-sep-参数自定义分隔符"><span>print() 函数默认使用空格分隔多个参数，但可以通过 sep 参数自定义分隔符</span></a></h4><h4 id="xxx-单下划线-约定俗成-非语法-标识「内部使用」-提示开发者勿外部调用-可直接访问-不推荐" tabindex="-1"><a class="header-anchor" href="#xxx-单下划线-约定俗成-非语法-标识「内部使用」-提示开发者勿外部调用-可直接访问-不推荐"><span>_xxx（单下划线：约定俗成（非语法），标识「内部使用」，提示开发者勿外部调用,可直接访问（不推荐）</span></a></h4><h4 id="xxx-前后双下划线-内置魔法方法-实现类的特殊功能-如构造、格式化等-可直接访问-通常通过内置函数间接调用-如str-obj-等价于obj-str" tabindex="-1"><a class="header-anchor" href="#xxx-前后双下划线-内置魔法方法-实现类的特殊功能-如构造、格式化等-可直接访问-通常通过内置函数间接调用-如str-obj-等价于obj-str"><span>__xxx__（前后双下划线）:内置魔法方法,实现类的特殊功能（如构造、格式化等）,可直接访问，通常通过内置函数间接调用（如str(obj)等价于obj.__str__()）</span></a></h4><h4 id="xxx-双下划线-语法特性-名称改写-直接访问访问不到-可以通过改写后的名称访问-避免子类覆盖、实现真正封装-无法直接访问-可通过-类名-xxx访问-不推荐" tabindex="-1"><a class="header-anchor" href="#xxx-双下划线-语法特性-名称改写-直接访问访问不到-可以通过改写后的名称访问-避免子类覆盖、实现真正封装-无法直接访问-可通过-类名-xxx访问-不推荐"><span>__xxx（双下划线）:语法特性（名称改写,直接访问访问不到，可以通过改写后的名称访问）,避免子类覆盖、实现真正封装，无法直接访问，可通过_类名__xxx访问（不推荐）</span></a></h4><h4 id="对象判断布尔真假规则本质-优先调用-bool-self-未定义-bool-则调用-len-self-兜底-两者均未定义-对象默认恒为-true" tabindex="-1"><a class="header-anchor" href="#对象判断布尔真假规则本质-优先调用-bool-self-未定义-bool-则调用-len-self-兜底-两者均未定义-对象默认恒为-true"><span>对象判断布尔真假规则本质，优先调用__bool__(self)，未定义__bool__()，则调用__len__(self) 兜底，两者均未定义，对象默认恒为 True</span></a></h4><h4 id="eq-方法就是-相等运算符的底层实现逻辑-可以类比java中的equals方进行理解" tabindex="-1"><a class="header-anchor" href="#eq-方法就是-相等运算符的底层实现逻辑-可以类比java中的equals方进行理解"><span>__eq__ 方法就是 == 相等运算符的底层实现逻辑，可以类比java中的equals方进行理解</span></a></h4><h4 id="repr-于返回对象无歧义、可精准重建的字符串表示-专供开发者调试与交互式环境使用-print-对象-默认调用-str-若类未定义-str-会自动兜底调用-repr-替代-除此之外-在终端-idle-pycharm-控制台直接输入对象名回车-会无条件调用-repr-展示结果-当对象作为-列表、元组、字典、集合-等容器的元素时-打印-查看容器-容器内所有元素都会统一调用自身的-repr-哪怕元素定义了-str-也无效-。" tabindex="-1"><a class="header-anchor" href="#repr-于返回对象无歧义、可精准重建的字符串表示-专供开发者调试与交互式环境使用-print-对象-默认调用-str-若类未定义-str-会自动兜底调用-repr-替代-除此之外-在终端-idle-pycharm-控制台直接输入对象名回车-会无条件调用-repr-展示结果-当对象作为-列表、元组、字典、集合-等容器的元素时-打印-查看容器-容器内所有元素都会统一调用自身的-repr-哪怕元素定义了-str-也无效-。"><span>__repr__ 于返回对象无歧义、可精准重建的字符串表示，专供开发者调试与交互式环境使用；print(对象) 默认调用__str__，若类未定义__str__，会自动兜底调用__repr__ 替代,除此之外，在终端 / IDLE/PyCharm 控制台直接输入对象名回车，会无条件调用__repr__ 展示结果，当对象作为 列表、元组、字典、集合 等容器的元素时，打印 / 查看容器，容器内所有元素都会统一调用自身的__repr__（哪怕元素定义了__str__也无效）。</span></a></h4><h4 id="new-是-python-类的静态方法-首参为类本身cls-核心职责是分配内存、创建空白实例对象-是实例的-创造者-必须返回一个实例对象-返回有效实例才会触发后续流程-无返回则实例创建失败-可控制实例的创建规则-如单例模式、限制实例数量-init-是实例方法-首参为new创建的实例self-核心职责是为空白实例绑定属性、赋值初始值-是实例的-初始化器-强制无返回值-仅能返回-none-写-return-会抛异常-二者是-python-实例化的绑定执行流程-new优先执行-创建实例后自动将其传给init的self并触发init执行-共同完成实例的完整生成-核心区别在于new操作类、管控创建过程、必须有返回值-init操作已存在的实例、仅做初始化、无返回值-new用于特殊的实例创建管控场景-init是日常自定义类绑定属性的标配。" tabindex="-1"><a class="header-anchor" href="#new-是-python-类的静态方法-首参为类本身cls-核心职责是分配内存、创建空白实例对象-是实例的-创造者-必须返回一个实例对象-返回有效实例才会触发后续流程-无返回则实例创建失败-可控制实例的创建规则-如单例模式、限制实例数量-init-是实例方法-首参为new创建的实例self-核心职责是为空白实例绑定属性、赋值初始值-是实例的-初始化器-强制无返回值-仅能返回-none-写-return-会抛异常-二者是-python-实例化的绑定执行流程-new优先执行-创建实例后自动将其传给init的self并触发init执行-共同完成实例的完整生成-核心区别在于new操作类、管控创建过程、必须有返回值-init操作已存在的实例、仅做初始化、无返回值-new用于特殊的实例创建管控场景-init是日常自定义类绑定属性的标配。"><span>__new__是 Python 类的静态方法，首参为类本身cls，核心职责是分配内存、创建空白实例对象，是实例的 “创造者”，必须返回一个实例对象（返回有效实例才会触发后续流程，无返回则实例创建失败），可控制实例的创建规则（如单例模式、限制实例数量）__init__是实例方法，首参为new创建的实例self，核心职责是为空白实例绑定属性、赋值初始值，是实例的 “初始化器”，强制无返回值（仅能返回 None，写 return 会抛异常）；二者是 Python 实例化的绑定执行流程，new优先执行，创建实例后自动将其传给init的self并触发init执行，共同完成实例的完整生成，核心区别在于new操作类、管控创建过程、必须有返回值，init操作已存在的实例、仅做初始化、无返回值，new用于特殊的实例创建管控场景，init是日常自定义类绑定属性的标配。</span></a></h4><h4 id="mul-用于定义普通乘法-运算-执行时返回新对象且绝不会修改原对象-imul-用于定义原地乘法-运算-优先被-调用-通常由列表-list-这类可变对象实现-逻辑是直接修改原对象的内部数据并返回自身-以此实现原地优化-对于整数-int-、字符串-str-这类不可变对象-其本身无法被原地修改-因此不会实现-imul-当对不可变对象执行-时-会自动退化为调用-mul-创建新对象-再将新对象重新赋值给原变量-二者的设计分别适配了-python-中不可变对象的创建性运算、可变对象的原地优化运算逻辑-且-始终优先尝试调用-imul-未实现时才降级使用-mul-完成运算。" tabindex="-1"><a class="header-anchor" href="#mul-用于定义普通乘法-运算-执行时返回新对象且绝不会修改原对象-imul-用于定义原地乘法-运算-优先被-调用-通常由列表-list-这类可变对象实现-逻辑是直接修改原对象的内部数据并返回自身-以此实现原地优化-对于整数-int-、字符串-str-这类不可变对象-其本身无法被原地修改-因此不会实现-imul-当对不可变对象执行-时-会自动退化为调用-mul-创建新对象-再将新对象重新赋值给原变量-二者的设计分别适配了-python-中不可变对象的创建性运算、可变对象的原地优化运算逻辑-且-始终优先尝试调用-imul-未实现时才降级使用-mul-完成运算。"><span>mul 用于定义普通乘法 * 运算，执行时返回新对象且绝不会修改原对象；imul 用于定义原地乘法 = 运算，优先被*=调用，通常由列表（list）这类可变对象实现，逻辑是直接修改原对象的内部数据并返回自身，以此实现原地优化；对于整数（int）、字符串（str）这类不可变对象，其本身无法被原地修改，因此不会实现__imul__，当对不可变对象执行= 时，会自动退化为调用__mul__创建新对象，再将新对象重新赋值给原变量，二者的设计分别适配了 Python 中不可变对象的创建性运算、可变对象的原地优化运算逻辑，且 *= 始终优先尝试调用__imul__，未实现时才降级使用__mul__完成运算。</span></a></h4><h4 id="python-中所有参数传递都是-按对象引用传递-传递的是对象的引用-内存地址-对于不可变对象-函数内修改会创建新对象-不影响外部-对于可变对象-函数内修改会影响外部" tabindex="-1"><a class="header-anchor" href="#python-中所有参数传递都是-按对象引用传递-传递的是对象的引用-内存地址-对于不可变对象-函数内修改会创建新对象-不影响外部-对于可变对象-函数内修改会影响外部"><span>Python 中所有参数传递都是 “按对象引用传递” ，传递的是对象的引用（内存地址） ，对于不可变对象，函数内修改会创建新对象，不影响外部 ，对于可变对象，函数内修改会影响外部</span></a></h4><h4 id="python-的内建作用域在底层由-builtins-模块实现-该模块定义了所有内置函数、异常与常量。代码中可直接访问-len、print-等内置名称-是因为解释器会遵循-legb-作用域查找链-自动向内建作用域-即-builtins-模块-查找实现。builtins-模块属于-cpython-解释器的实现细节-虽归-python-标准库且可显式导入-但开发者通常无需直接依赖它-仅在需要修改或扩展内置行为时才考虑使用。在全局作用域中-主模块会以-builtins-作为内建作用域的引用-直接指向-builtins-模块对象-非主模块的-builtins-则多为-builtins-模块的-dict-属性-局部作用域的名称查找严格遵循-legb-规则-逐级向上直至内建作用域-而不依赖-builtins-属性。cpython-解释器可能在优化场景下缓存内建作用域的引用-以提升局部作用域的名称查找效率-这一行为属于解释器内部实现细节-无明确规范约束-也无法保证跨-python-版本或跨解释器-如-pypy、jython-的兼容性-开发者绝对不应依赖此类细节进行编码。" tabindex="-1"><a class="header-anchor" href="#python-的内建作用域在底层由-builtins-模块实现-该模块定义了所有内置函数、异常与常量。代码中可直接访问-len、print-等内置名称-是因为解释器会遵循-legb-作用域查找链-自动向内建作用域-即-builtins-模块-查找实现。builtins-模块属于-cpython-解释器的实现细节-虽归-python-标准库且可显式导入-但开发者通常无需直接依赖它-仅在需要修改或扩展内置行为时才考虑使用。在全局作用域中-主模块会以-builtins-作为内建作用域的引用-直接指向-builtins-模块对象-非主模块的-builtins-则多为-builtins-模块的-dict-属性-局部作用域的名称查找严格遵循-legb-规则-逐级向上直至内建作用域-而不依赖-builtins-属性。cpython-解释器可能在优化场景下缓存内建作用域的引用-以提升局部作用域的名称查找效率-这一行为属于解释器内部实现细节-无明确规范约束-也无法保证跨-python-版本或跨解释器-如-pypy、jython-的兼容性-开发者绝对不应依赖此类细节进行编码。"><span>Python 的内建作用域在底层由 builtins 模块实现，该模块定义了所有内置函数、异常与常量。代码中可直接访问 len、print 等内置名称，是因为解释器会遵循 LEGB 作用域查找链，自动向内建作用域（即 builtins 模块）查找实现。builtins 模块属于 CPython 解释器的实现细节，虽归 Python 标准库且可显式导入，但开发者通常无需直接依赖它，仅在需要修改或扩展内置行为时才考虑使用。在全局作用域中，主模块会以 <strong>builtins</strong> 作为内建作用域的引用（直接指向 builtins 模块对象），非主模块的 <strong>builtins</strong> 则多为 builtins 模块的 <strong>dict</strong> 属性；局部作用域的名称查找严格遵循 LEGB 规则，逐级向上直至内建作用域，而不依赖 <strong>builtins</strong> 属性。CPython 解释器可能在优化场景下缓存内建作用域的引用，以提升局部作用域的名称查找效率，这一行为属于解释器内部实现细节，无明确规范约束，也无法保证跨 Python 版本或跨解释器（如 PyPy、Jython）的兼容性，开发者绝对不应依赖此类细节进行编码。</span></a></h4><h2 id="python-容器" tabindex="-1"><a class="header-anchor" href="#python-容器"><span>python 容器</span></a></h2><h4 id="list中list-sort-是列表的原地排序方法-会直接修改原列表-sorted-list-是内置函数-内部会先复制原列表-然后对新列表进行排序-最后返回这个新列表-即不改变原列表" tabindex="-1"><a class="header-anchor" href="#list中list-sort-是列表的原地排序方法-会直接修改原列表-sorted-list-是内置函数-内部会先复制原列表-然后对新列表进行排序-最后返回这个新列表-即不改变原列表"><span>list中list.sort() 是列表的原地排序方法，会直接修改原列表；sorted(list) 是内置函数，内部会先复制原列表，然后对新列表进行排序，最后返回这个新列表，即不改变原列表</span></a></h4><h2 id="生成器" tabindex="-1"><a class="header-anchor" href="#生成器"><span>生成器</span></a></h2><h4 id="生成器是定义中包含-yield-的函数-调用该函数并不会执行函数体-而是直接获得一个生成器实例-可以看成允许多次暂停、恢复的特殊的函数一次调用-生成器执行时遇到-yield-会暂停并返回其后的值-next-等价于-send-none-或-send-可让其恢复执行-直到函数体执行完毕-生成器耗尽-生成器的迭代本质是遍历多次-yield-返回的值-恢复执行时-yield-表达式会接收值-——send-可传入具体值-而-next-仅传入-none-直至生成器最终耗尽。" tabindex="-1"><a class="header-anchor" href="#生成器是定义中包含-yield-的函数-调用该函数并不会执行函数体-而是直接获得一个生成器实例-可以看成允许多次暂停、恢复的特殊的函数一次调用-生成器执行时遇到-yield-会暂停并返回其后的值-next-等价于-send-none-或-send-可让其恢复执行-直到函数体执行完毕-生成器耗尽-生成器的迭代本质是遍历多次-yield-返回的值-恢复执行时-yield-表达式会接收值-——send-可传入具体值-而-next-仅传入-none-直至生成器最终耗尽。"><span>生成器是定义中包含 yield 的函数，调用该函数并不会执行函数体，而是直接获得一个生成器实例（可以看成允许多次暂停、恢复的特殊的函数一次调用）；生成器执行时遇到 yield 会暂停并返回其后的值，next ()（等价于 send (None)）或 send () 可让其恢复执行，直到函数体执行完毕（生成器耗尽）；生成器的迭代本质是遍历多次 yield 返回的值，恢复执行时 yield 表达式会接收值 ——send () 可传入具体值，而 next () 仅传入 None，直至生成器最终耗尽。</span></a></h4><h4 id="contextmanager-装饰器将生成器函数转换为上下文管理器-yield-语句首次执行前的代码等价于上下文管理器的-enter-方法-进入上下文时执行-yield-语句产生的首个值-是-with-as-语句中-as-后变量接收的值-无返回值时可仅写-yield-yield-语句首次执行后的所有代码-包括多轮-yield-后续逻辑-等价于上下文管理器的-exit-方法-退出上下文时执行-。需要注意的是-contextmanager-封装的上下文管理器仅会执行到生成器的首个-yield-后续多轮-yield-不会被触发-若生成器包含多轮-yield-超出首个-yield-的逻辑需通过其他方式触发-并非上下文管理器的默认行为-。" tabindex="-1"><a class="header-anchor" href="#contextmanager-装饰器将生成器函数转换为上下文管理器-yield-语句首次执行前的代码等价于上下文管理器的-enter-方法-进入上下文时执行-yield-语句产生的首个值-是-with-as-语句中-as-后变量接收的值-无返回值时可仅写-yield-yield-语句首次执行后的所有代码-包括多轮-yield-后续逻辑-等价于上下文管理器的-exit-方法-退出上下文时执行-。需要注意的是-contextmanager-封装的上下文管理器仅会执行到生成器的首个-yield-后续多轮-yield-不会被触发-若生成器包含多轮-yield-超出首个-yield-的逻辑需通过其他方式触发-并非上下文管理器的默认行为-。"><span>@contextmanager 装饰器将生成器函数转换为上下文管理器：yield 语句首次执行前的代码等价于上下文管理器的__enter__ 方法（进入上下文时执行）；yield 语句产生的首个值，是 with ... as 语句中 as 后变量接收的值（无返回值时可仅写 yield）；yield 语句首次执行后的所有代码（包括多轮 yield 后续逻辑）等价于上下文管理器的__exit__ 方法（退出上下文时执行）。需要注意的是，@contextmanager 封装的上下文管理器仅会执行到生成器的首个 yield，后续多轮 yield 不会被触发（若生成器包含多轮 yield，超出首个 yield 的逻辑需通过其他方式触发，并非上下文管理器的默认行为）。</span></a></h4><h4 id="通过-yield-关键字将遍历逻辑封装为生成器-调用时不会一次性生成并返回所有遍历结果-而是以-执行到-yield-处返回一个值并暂停-→-等待下一次请求再恢复执行-的方式-实现可暂停、可恢复的可控遍历。" tabindex="-1"><a class="header-anchor" href="#通过-yield-关键字将遍历逻辑封装为生成器-调用时不会一次性生成并返回所有遍历结果-而是以-执行到-yield-处返回一个值并暂停-→-等待下一次请求再恢复执行-的方式-实现可暂停、可恢复的可控遍历。"><span>通过 yield 关键字将遍历逻辑封装为生成器，调用时不会一次性生成并返回所有遍历结果，而是以 “执行到 yield 处返回一个值并暂停 → 等待下一次请求再恢复执行” 的方式，实现可暂停、可恢复的可控遍历。</span></a></h4><div class="language-python line-numbers-mode" data-highlighter="prismjs" data-ext="py"><pre><code><span class="line"><span class="token keyword">def</span> <span class="token function">square_generator</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token punctuation">:</span></span>\n<span class="line">    <span class="token triple-quoted-string string">&quot;&quot;&quot;一个生成数字平方的生成器函数&quot;&quot;&quot;</span></span>\n<span class="line">    <span class="token keyword">for</span> num <span class="token keyword">in</span> numbers<span class="token punctuation">:</span></span>\n<span class="line">        <span class="token comment"># 遇到yield，返回当前值的平方，然后函数在此暂停</span></span>\n<span class="line">        <span class="token keyword">yield</span> num <span class="token operator">*</span> num</span>\n<span class="line">        <span class="token comment"># 当生成器的__next__()被再次调用时，从这里恢复执行</span></span>\n<span class="line"></span>\n<span class="line"><span class="token comment"># 创建一个生成器对象</span></span>\n<span class="line">my_numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span></span>\n<span class="line">squares <span class="token operator">=</span> square_generator<span class="token punctuation">(</span>my_numbers<span class="token punctuation">)</span></span>\n<span class="line"></span>\n<span class="line"><span class="token comment"># 第一次调用next()，函数执行到第一个yield处暂停</span></span>\n<span class="line"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">next</span><span class="token punctuation">(</span>squares<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 输出: 1</span></span>\n<span class="line"></span>\n<span class="line"><span class="token comment"># 第二次调用next()，函数从上次暂停处恢复，执行循环的下一次迭代，到yield处再次暂停</span></span>\n<span class="line"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">next</span><span class="token punctuation">(</span>squares<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 输出: 4</span></span>\n<span class="line"></span>\n<span class="line"><span class="token comment"># 第三次调用next()</span></span>\n<span class="line"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">next</span><span class="token punctuation">(</span>squares<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 输出: 9</span></span>\n<span class="line"></span>\n<span class="line"><span class="token comment"># 生成器也可以用在for循环中，for循环会自动处理next()和StopIteration</span></span>\n<span class="line"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;使用for循环遍历剩余的值:&quot;</span><span class="token punctuation">)</span></span>\n<span class="line"><span class="token keyword">for</span> value <span class="token keyword">in</span> squares<span class="token punctuation">:</span> <span class="token comment"># 注意：此时生成器内部已经执行到第4个元素</span></span>\n<span class="line">    <span class="token keyword">print</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span></span>\n<span class="line"><span class="token comment"># 输出:</span></span>\n<span class="line"><span class="token comment"># 16</span></span>\n<span class="line"><span class="token comment"># 25</span></span>\n<span class="line"></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="类型注解" tabindex="-1"><a class="header-anchor" href="#类型注解"><span>类型注解</span></a></h2><h4 id="python中类型注解与实际的属性值实际赋值不要求一致-只是一种提示作用-编译器完全允许-仅静态检查工具-如mypy-会根据注解进行类型检查-如pydantic-sqlalchemy等都利用了这种类型注解的特性-仅为注释-无实际效果-然后提供对应的如mypy插件-让静态工具可以识别-从而不报错" tabindex="-1"><a class="header-anchor" href="#python中类型注解与实际的属性值实际赋值不要求一致-只是一种提示作用-编译器完全允许-仅静态检查工具-如mypy-会根据注解进行类型检查-如pydantic-sqlalchemy等都利用了这种类型注解的特性-仅为注释-无实际效果-然后提供对应的如mypy插件-让静态工具可以识别-从而不报错"><span>Python中类型注解与实际的属性值实际赋值不要求一致，只是一种提示作用，编译器完全允许，仅静态检查工具（如mypy）会根据注解进行类型检查，如Pydantic/SQlAlchemy等都利用了这种类型注解的特性（仅为注释，无实际效果），然后提供对应的如mypy插件，让静态工具可以识别，从而不报错</span></a></h4><h2 id="常用类" tabindex="-1"><a class="header-anchor" href="#常用类"><span>常用类</span></a></h2><h4 id="queue-get-从队列取出数据-物理操作-而task-done-和-join-的操作对象都是内部计数器-分别是减少内部计数器-逻辑标记-和检查计数器是否归零-同步等待" tabindex="-1"><a class="header-anchor" href="#queue-get-从队列取出数据-物理操作-而task-done-和-join-的操作对象都是内部计数器-分别是减少内部计数器-逻辑标记-和检查计数器是否归零-同步等待"><span>Queue::get() 从队列取出数据（物理操作），而task_done() 和 join() 的操作对象都是内部计数器，分别是减少内部计数器（逻辑标记）和检查计数器是否归零（同步等待）_</span></a></h4><h2 id="异常" tabindex="-1"><a class="header-anchor" href="#异常"><span>异常</span></a></h2><h4 id="python-所有异常或错误均直接或间接继承-baseexception-无-java-的-exception-error-划分-工程上绝大多数场景禁止-except-except-baseexception捕获所有异常-工程开发中-99-的业务场景只需捕获-exception-baseexception-的其他直接子类-属于「不应被业务代码捕获」的范畴。" tabindex="-1"><a class="header-anchor" href="#python-所有异常或错误均直接或间接继承-baseexception-无-java-的-exception-error-划分-工程上绝大多数场景禁止-except-except-baseexception捕获所有异常-工程开发中-99-的业务场景只需捕获-exception-baseexception-的其他直接子类-属于「不应被业务代码捕获」的范畴。"><span>Python 所有异常或错误均直接或间接继承 BaseException，无 Java 的 Exception/Error 划分，工程上绝大多数场景禁止 except: / except BaseException捕获所有异常，工程开发中，99% 的业务场景只需捕获 Exception；BaseException 的其他直接子类，属于「不应被业务代码捕获」的范畴。</span></a></h4>',39)])])}]]),l=JSON.parse('{"path":"/andy-interview-and-outline/python/python-base.html","title":"Python Base","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Python ENV","slug":"python-env","link":"#python-env","children":[]},{"level":2,"title":"python 数据类型","slug":"python-数据类型","link":"#python-数据类型","children":[]},{"level":2,"title":"","slug":"","link":"#","children":[]},{"level":2,"title":"python 函数","slug":"python-函数","link":"#python-函数","children":[]},{"level":2,"title":"python 容器","slug":"python-容器","link":"#python-容器","children":[]},{"level":2,"title":"生成器","slug":"生成器","link":"#生成器","children":[]},{"level":2,"title":"类型注解","slug":"类型注解","link":"#类型注解","children":[]},{"level":2,"title":"常用类","slug":"常用类","link":"#常用类","children":[]},{"level":2,"title":"异常","slug":"异常","link":"#异常","children":[]}],"git":{"updatedTime":1769950789000,"contributors":[{"name":"xiang.han","username":"","email":"839462320@qq.com","commits":16},{"name":"WhaleFall","username":"WhaleFall","email":"839462320@qq.com","commits":14,"url":"https://github.com/WhaleFall"}],"changelog":[{"hash":"53cc3b62a9a2ecf1432494d90922286eb5524c81","time":1769950789000,"email":"839462320@qq.com","author":"xiang.han","message":"docs(python): 更新 Python 基础文档中的函数和作用域说明"},{"hash":"a8e8a7f187f3ce49d653c58c11e7a3a5fefee13c","time":1769949807000,"email":"839462320@qq.com","author":"xiang.han","message":"docs(python): 更新Python基础文档添加mul和imul运算符说明"},{"hash":"7e909b79421cfb66c20cfb754e72090697d36281","time":1769949469000,"email":"839462320@qq.com","author":"xiang.han","message":"docs(python): 更新Python基础文档内容"},{"hash":"3f875c652de3b710b238b7a1e2a53a4e6cb2e1ce","time":1769948767000,"email":"839462320@qq.com","author":"xiang.han","message":"docs(python): 更新Python基础文档内容"},{"hash":"f7a5c1f0c5a5a984a7d437553dfb6f30eba9ed63","time":1769247520000,"email":"839462320@qq.com","author":"WhaleFall","message":"docs(python): 更新 Python 基础文档中 print() 函数说明"},{"hash":"38450f1750093bf16f4dcb52ed551d3b49e59541","time":1768926048000,"email":"839462320@qq.com","author":"xiang.han","message":"2026/01/21 00:20:46"},{"hash":"cdb47a9b5e39e76a08f92944ff529c3c86e4747e","time":1767840249000,"email":"839462320@qq.com","author":"WhaleFall","message":"2026-01-08 10:44:08"},{"hash":"c513c4d2a08ad74fbebfc6b77c6ad848b9c8667d","time":1767840234000,"email":"839462320@qq.com","author":"WhaleFall","message":"2026-01-08 10:43:53"},{"hash":"d40f9fe671ac1340f10a1803f40bcd77be440c5b","time":1767767438000,"email":"839462320@qq.com","author":"WhaleFall","message":"2026-01-07 14:30:37"},{"hash":"f79de09d646fc1095e00882f874b9d02da54832c","time":1767767438000,"email":"839462320@qq.com","author":"WhaleFall","message":"2026-01-07 14:30:37"},{"hash":"f43ba55706af7f9718b528e2893e397e68aa2243","time":1767766784000,"email":"839462320@qq.com","author":"WhaleFall","message":"docs(python): 更新Python基础文档内容"},{"hash":"a527e2401afdabd696297755e08dc7fd79585677","time":1767765629000,"email":"839462320@qq.com","author":"WhaleFall","message":"docs(python): 添加生成器相关内容"},{"hash":"c3015190e6efeedc1edf6739fe42b7cf861d16c8","time":1767682450000,"email":"839462320@qq.com","author":"WhaleFall","message":"docs(python): 更新Python基础文档内容"},{"hash":"43f3e958393766a4a1a0713a9cd8977343217e60","time":1767624970000,"email":"839462320@qq.com","author":"xiang.han","message":"2026/01/05 22:56:09"},{"hash":"1aef5b53052e1a29e40f388c1c8aa428e3b3609b","time":1767589653000,"email":"839462320@qq.com","author":"WhaleFall","message":"2026-01-05 13:07:32"},{"hash":"a4232ef4cef4e4a7c6da5d77582b740259ba6fdc","time":1767581697000,"email":"839462320@qq.com","author":"WhaleFall","message":"2026-01-05 10:31:21"},{"hash":"c229085061090029f6094d7ca002ac8db1824911","time":1767580281000,"email":"839462320@qq.com","author":"WhaleFall","message":"2026-01-05 10:31:21"},{"hash":"0ba6146d3aceabfaebda11d8edf734c93a04f7d3","time":1767573053000,"email":"839462320@qq.com","author":"xiang.han","message":"2026/01/04 23:25:28"},{"hash":"c410737aff864641aaa207c0690dfcab258a9d4c","time":1767540330000,"email":"839462320@qq.com","author":"xiang.han","message":"2026/01/04 23:25:28"},{"hash":"860cc4599d9e88f2b2a091761fe94df466eaeec4","time":1767540048000,"email":"839462320@qq.com","author":"xiang.han","message":"2026/01/04 23:20:42"},{"hash":"92ff78c85cc7a506f3ba63b71ebf9625ceb505fe","time":1767188349000,"email":"839462320@qq.com","author":"WhaleFall","message":"2025-12-26 15:25:17"},{"hash":"fe51959dc9c32aa0983b27d8957a2d133c544592","time":1766733918000,"email":"839462320@qq.com","author":"WhaleFall","message":"2025-12-26 15:25:17"},{"hash":"288a28489faad60ead8e402ac3957d14b23b6d20","time":1766403559000,"email":"839462320@qq.com","author":"WhaleFall","message":"2025-12-22 19:39:19"},{"hash":"182d79c8cfbcaa766c8e40e04efa49d33a1b4dce","time":1766329602000,"email":"839462320@qq.com","author":"xiang.han","message":"2025/12/21 23:06:39"},{"hash":"c345cc4e1d845df71f8180449110d3182fbb9fa2","time":1766288471000,"email":"839462320@qq.com","author":"xiang.han","message":"2025/12/21 11:41:10"},{"hash":"1999c1dbad243a67a38cc70dc97997eb7dd17c42","time":1766226508000,"email":"839462320@qq.com","author":"xiang.han","message":"2025/12/20 18:28:27"},{"hash":"0babf7953ecbc5bbf5922f232d1a68fe7d1a6cf7","time":1766226190000,"email":"839462320@qq.com","author":"xiang.han","message":"2025/12/20 18:23:09"},{"hash":"ae3076292b478ba1f95085f7ff10a0d3e9a64645","time":1766225563000,"email":"839462320@qq.com","author":"xiang.han","message":"2025/12/20 18:12:42"},{"hash":"8399375e5b07005d3fe963bcbeace591c3fbe640","time":1766224951000,"email":"839462320@qq.com","author":"xiang.han","message":"2025/12/20 18:02:30"},{"hash":"39b9caf5eeb95ee54482df892e6579b35818c990","time":1766224561000,"email":"839462320@qq.com","author":"xiang.han","message":"2025/12/20 17:55:59"}]},"filePathRelative":"andy-interview-and-outline/python/python-base.md","excerpt":"\\n<h2>Python ENV</h2>\\n<h4>pip::pip 安装 requirements.txt 依赖： pip install -r requirements.txt</h4>\\n<h4>conda::conda关闭默认base激活</h4>\\n<h4>uv::uv创建虚拟环境</h4>\\n<h4>uv::windows下激活指定位置nv环境,powershell终端执行 安装目录\\\\Script\\\\Activate.ps1</h4>\\n<h4>uv::windows下激活指定位置nv环境cmdl终端执行 安装目录\\\\Script\\\\Activate.bat</h4>\\n<h2>python 数据类型</h2>"}')}}]);