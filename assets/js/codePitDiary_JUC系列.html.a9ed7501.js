"use strict";(self.webpackChunkandy_blogs=self.webpackChunkandy_blogs||[]).push([[710],{3566:(e,l,a)=>{a.r(l),a.d(l,{comp:()=>u,data:()=>r});var n=a(2565);const i={class:"table-of-contents"},t={},u=(0,a(7459).A)(t,[["render",function(e,l){const a=(0,n.g2)("router-link");return(0,n.uX)(),(0,n.CE)("div",null,[l[1]||(l[1]=(0,n.Lk)("h1",{id:"juc-系列",tabindex:"-1"},[(0,n.Lk)("a",{class:"header-anchor",href:"#juc-系列"},[(0,n.Lk)("span",null,"JUC 系列")])],-1)),l[2]||(l[2]=(0,n.Lk)("p",null,"[TOC]",-1)),(0,n.Lk)("nav",i,[(0,n.Lk)("ul",null,[(0,n.Lk)("li",null,[(0,n.bF)(a,{to:"#线程池"},{default:(0,n.k6)(()=>[...l[0]||(l[0]=[(0,n.eW)("线程池",-1)])]),_:1})])])]),l[3]||(l[3]=(0,n.Fv)('<h2 id="线程池" tabindex="-1"><a class="header-anchor" href="#线程池"><span>线程池</span></a></h2><h4 id="取消线程池中的正在执行的任务" tabindex="-1"><a class="header-anchor" href="#取消线程池中的正在执行的任务"><span>取消线程池中的正在执行的任务</span></a></h4><ul><li>前置 <ul><li>线程池的submit不会抛出异常，而是捕获异常，将异常封装到Future中返回</li><li>线程池的execute会抛出异常</li><li>当线程因 InterruptedException（打断异常）退出阻塞状态时，JVM 会自动将该线程的打断标志重置为 false，这是 Java 中断机制的核心特性</li><li>Java 没有 “强制终止线程” 的安全方法，只能通过中断（interrupt） 通知线程停止执行，任务需主动检测中断状态并退出。 <ul><li>关键工具：Future对象（提交任务时返回），通过Future.cancel(boolean mayInterruptIfRunning)方法触发取消：</li><li>任务层面：必须在任务中检测中断状态（如Thread.interrupted()或isInterrupted()），并主动退出，否则即使调用cancel(true) 也无法停止任务。 <ul><li>如果任务不检测中断状态、也不调用可中断的阻塞方法，即使调用cancel(true)也无法停止</li></ul></li></ul></li><li>线程池中的复用线程（核心线程或未超时的非核心线程），在执行下一个新任务前，会默认清除自身的中断标志—— 这是 ThreadPoolExecutor 的默认实现，目的是保证任务执行环境的独立性。</li></ul></li><li>实践</li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>',4))])}]]),r=JSON.parse('{"path":"/codePitDiary/JUC%E7%B3%BB%E5%88%97.html","title":"JUC 系列","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"线程池","slug":"线程池","link":"#线程池","children":[]}],"git":{"updatedTime":1764567543000,"contributors":[{"name":"WhaleFall","username":"WhaleFall","email":"839462320@qq.com","commits":2,"url":"https://github.com/WhaleFall"}],"changelog":[{"hash":"c6d9031b9ab2f4bbf0e16c1735200c25b9216a27","time":1764567543000,"email":"839462320@qq.com","author":"WhaleFall","message":"2025-12-01 13:39:02"},{"hash":"452c4eaf6a7be6faa66a03c705f2ed7bb2a08764","time":1764557042000,"email":"839462320@qq.com","author":"WhaleFall","message":"2025-12-01 10:44:01"}]},"filePathRelative":"codePitDiary/JUC系列.md","excerpt":"\\n<p>[TOC]</p>\\n\\n<h2>线程池</h2>\\n<h4>取消线程池中的正在执行的任务</h4>\\n<ul>\\n<li>前置\\n<ul>\\n<li>线程池的submit不会抛出异常，而是捕获异常，将异常封装到Future中返回</li>\\n<li>线程池的execute会抛出异常</li>\\n<li>当线程因 InterruptedException（打断异常）退出阻塞状态时，JVM 会自动将该线程的打断标志重置为 false，这是 Java 中断机制的核心特性</li>\\n<li>Java 没有 “强制终止线程” 的安全方法，只能通过中断（interrupt） 通知线程停止执行，任务需主动检测中断状态并退出。\\n<ul>\\n<li>关键工具：Future对象（提交任务时返回），通过Future.cancel(boolean mayInterruptIfRunning)方法触发取消：</li>\\n<li>任务层面：必须在任务中检测中断状态（如Thread.interrupted()或isInterrupted()），并主动退出，否则即使调用cancel(true)\\n也无法停止任务。\\n<ul>\\n<li>如果任务不检测中断状态、也不调用可中断的阻塞方法，即使调用cancel(true)也无法停止</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>线程池中的复用线程（核心线程或未超时的非核心线程），在执行下一个新任务前，会默认清除自身的中断标志—— 这是 ThreadPoolExecutor 的默认实现，目的是保证任务执行环境的独立性。</li>\\n</ul>\\n</li>\\n<li>实践</li>\\n</ul>"}')}}]);