"use strict";(self.webpackChunkandy_blogs=self.webpackChunkandy_blogs||[]).push([[163],{3126:(e,a,s)=>{s.r(a),s.d(a,{comp:()=>n,data:()=>c});var t=s(2565);const h={},n=(0,s(7459).A)(h,[["render",function(e,a){return(0,t.uX)(),(0,t.CE)("div",null,[...a[0]||(a[0]=[(0,t.Fv)('<h1 id="architecture" tabindex="-1"><a class="header-anchor" href="#architecture"><span>Architecture</span></a></h1><h3 id="状态码和错误码" tabindex="-1"><a class="header-anchor" href="#状态码和错误码"><span>状态码和错误码</span></a></h3><h4 id="http状态码信息有限-所以需要自定义错误码-以面对不同的业务场景" tabindex="-1"><a class="header-anchor" href="#http状态码信息有限-所以需要自定义错误码-以面对不同的业务场景"><span>http状态码信息有限，所以需要自定义错误码，以面对不同的业务场景</span></a></h4><h4 id="推荐的错误码定义方式是-a-bb-cc-每个部分具体多少位数字自行约定-也可以使用字母等-其中-a-为错误码类别-例如01-用户端错误-02-系统执行错误-03-第三发调用错误-b-为业务域-服务表示-例如001-用户中心-002-商品中心-c-为具体的错误编号-例如0001-0999是服务内通用错误-1000-9999是具体的错误码" tabindex="-1"><a class="header-anchor" href="#推荐的错误码定义方式是-a-bb-cc-每个部分具体多少位数字自行约定-也可以使用字母等-其中-a-为错误码类别-例如01-用户端错误-02-系统执行错误-03-第三发调用错误-b-为业务域-服务表示-例如001-用户中心-002-商品中心-c-为具体的错误编号-例如0001-0999是服务内通用错误-1000-9999是具体的错误码"><span>推荐的错误码定义方式是 A-BB-CC(每个部分具体多少位数字自行约定，也可以使用字母等)，其中 A 为错误码类别（例如01-用户端错误，02-系统执行错误，03-第三发调用错误），B 为业务域，服务表示（例如001-用户中心，002-商品中心），C 为具体的错误编号（例如0001-0999是服务内通用错误，1000-9999是具体的错误码）</span></a></h4><h4 id="响应体-response-设计-有2种-一种是始终使用200-业务成功与否-看body的里面的code-另一种是使用http状态码-业务成功与否-看http状态码-2种方式均可选-具体根据业务场景选择" tabindex="-1"><a class="header-anchor" href="#响应体-response-设计-有2种-一种是始终使用200-业务成功与否-看body的里面的code-另一种是使用http状态码-业务成功与否-看http状态码-2种方式均可选-具体根据业务场景选择"><span>响应体（Response）设计，有2种，一种是始终使用200，业务成功与否，看body的里面的code,另一种是使用http状态码，业务成功与否，看http状态码，2种方式均可选，具体根据业务场景选择</span></a></h4><h4 id="always-200的优点-1-网关友好-nginx、waf、cdn-等基础设施对-4xx-5xx-状态码有默认拦截-限流规则-业务返回-4xx-5xx-易触发网关防御机制-200-可避免误拦截-2-前端框架-如-axios-fetch-对-http-错误和业务逻辑错误的处理机制分离-200-让前端仅需统一从-response-data-中处理业务结果-3-穿透性强-微服务调用链-a→b→c-中-200-更易携带完整-json-错误体透传至上层-而-http-错误码易被中间层框架吞没-改写" tabindex="-1"><a class="header-anchor" href="#always-200的优点-1-网关友好-nginx、waf、cdn-等基础设施对-4xx-5xx-状态码有默认拦截-限流规则-业务返回-4xx-5xx-易触发网关防御机制-200-可避免误拦截-2-前端框架-如-axios-fetch-对-http-错误和业务逻辑错误的处理机制分离-200-让前端仅需统一从-response-data-中处理业务结果-3-穿透性强-微服务调用链-a→b→c-中-200-更易携带完整-json-错误体透传至上层-而-http-错误码易被中间层框架吞没-改写"><span>Always 200的优点：1.网关友好：Nginx、WAF、CDN 等基础设施对 4xx/5xx 状态码有默认拦截 / 限流规则，业务返回 4xx/5xx 易触发网关防御机制，200 可避免误拦截 2.前端框架（如 Axios/Fetch）对 HTTP 错误和业务逻辑错误的处理机制分离，200 让前端仅需统一从 response.data 中处理业务结果 3. 穿透性强：微服务调用链（A→B→C）中，200 更易携带完整 JSON 错误体透传至上层，而 HTTP 错误码易被中间层框架吞没 / 改写</span></a></h4><h4 id="标准响应体结构的示例-success-true-code-010010001-msg-success-data-null-usermsg-用户操作成功-devmsg-用户操作成功-solution-请联系管理员-traceid-1234567890-usermsg-用户提示信息-面向用户-devmsg-开发人员提示信息-面向开发人员-用于系统排查问题的-生产环境建议关闭-从而脱敏-solution-建议的操作-traceid-调用链追踪id-分布式链路追踪-当然还可以定义其他的内容-或者减少部分内容-按需配置就行" tabindex="-1"><a class="header-anchor" href="#标准响应体结构的示例-success-true-code-010010001-msg-success-data-null-usermsg-用户操作成功-devmsg-用户操作成功-solution-请联系管理员-traceid-1234567890-usermsg-用户提示信息-面向用户-devmsg-开发人员提示信息-面向开发人员-用于系统排查问题的-生产环境建议关闭-从而脱敏-solution-建议的操作-traceid-调用链追踪id-分布式链路追踪-当然还可以定义其他的内容-或者减少部分内容-按需配置就行"><span>标准响应体结构的示例：{“success”:true,“code”:“010010001,“msg”:“success”,“data”:null,userMsg:“用户操作成功”,devMsg:“用户操作成功”,solution:“请联系管理员”,traceId:“1234567890”},userMsg:用户提示信息，面向用户；devMsg:开发人员提示信息，面向开发人员，用于系统排查问题的，生产环境建议关闭，从而脱敏；solution:建议的操作；traceId:调用链追踪ID，分布式链路追踪；当然还可以定义其他的内容，或者减少部分内容，按需配置就行</span></a></h4><p>一般来说，如果使用了msg，那么就不需要userMsg了和devMsg了，反之使用了userMsg和devMsg，那么就不需要msg了</p><h4 id="一般来说对于标准的响应体-一般都是采用枚举类来定义异常-封装code和一些通用的message-并且会进行全局管理" tabindex="-1"><a class="header-anchor" href="#一般来说对于标准的响应体-一般都是采用枚举类来定义异常-封装code和一些通用的message-并且会进行全局管理"><span>一般来说对于标准的响应体，一般都是采用枚举类来定义异常，封装code和一些通用的message，并且会进行全局管理</span></a></h4><h4 id="一般会将业务系统的异常分为2类-一种是业务异常-如余额不足-一种是系统异常-如数据库异常-空指针等等" tabindex="-1"><a class="header-anchor" href="#一般会将业务系统的异常分为2类-一种是业务异常-如余额不足-一种是系统异常-如数据库异常-空指针等等"><span>一般会将业务系统的异常分为2类，一种是业务异常，如余额不足，一种是系统异常，如数据库异常，空指针等等</span></a></h4>',10)])])}]]),c=JSON.parse('{"path":"/andy-interview-and-outline/back-end/architecture/architecture.html","title":"Architecture","lang":"en-US","frontmatter":{},"headers":[{"level":3,"title":"状态码和错误码","slug":"状态码和错误码","link":"#状态码和错误码","children":[]}],"git":{"updatedTime":1768012933000,"contributors":[{"name":"xiang.han","username":"","email":"839462320@qq.com","commits":3}],"changelog":[{"hash":"d35a1466ea92d9c592c8c1f92ad715ca970f4bf1","time":1768012933000,"email":"839462320@qq.com","author":"xiang.han","message":"2026/01/10 10:42:12"},{"hash":"a79204f5568a41cb8254f3e715322e4d60713339","time":1768012749000,"email":"839462320@qq.com","author":"xiang.han","message":"2026/01/10 10:39:08"},{"hash":"3efc88604435b545133c3075cec688829d790224","time":1768012209000,"email":"839462320@qq.com","author":"xiang.han","message":"2026/01/10 10:30:07"}]},"filePathRelative":"andy-interview-and-outline/back-end/architecture/architecture.md","excerpt":"\\n<h3>状态码和错误码</h3>\\n<h4>http状态码信息有限，所以需要自定义错误码，以面对不同的业务场景</h4>\\n<h4>推荐的错误码定义方式是 A-BB-CC(每个部分具体多少位数字自行约定，也可以使用字母等)，其中 A 为错误码类别（例如01-用户端错误，02-系统执行错误，03-第三发调用错误），B 为业务域，服务表示（例如001-用户中心，002-商品中心），C 为具体的错误编号（例如0001-0999是服务内通用错误，1000-9999是具体的错误码）</h4>\\n<h4>响应体（Response）设计，有2种，一种是始终使用200，业务成功与否，看body的里面的code,另一种是使用http状态码，业务成功与否，看http状态码，2种方式均可选，具体根据业务场景选择</h4>"}')}}]);