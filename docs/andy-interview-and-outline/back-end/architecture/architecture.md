# Architecture

### 状态码和错误码

#### http状态码信息有限，所以需要自定义错误码，以面对不同的业务场景

#### 推荐的错误码定义方式是 A-BB-CC(每个部分具体多少位数字自行约定，也可以使用字母等)，其中 A 为错误码类别（例如01-用户端错误，02-系统执行错误，03-第三发调用错误），B 为业务域，服务表示（例如001-用户中心，002-商品中心），C 为具体的错误编号（例如0001-0999是服务内通用错误，1000-9999是具体的错误码）

#### 响应体（Response）设计，有2种，一种是始终使用200，业务成功与否，看body的里面的code,另一种是使用http状态码，业务成功与否，看http状态码，2种方式均可选，具体根据业务场景选择

#### Always 200的优点：1.网关友好：Nginx、WAF、CDN 等基础设施对 4xx/5xx 状态码有默认拦截 / 限流规则，业务返回 4xx/5xx 易触发网关防御机制，200 可避免误拦截 2.前端框架（如 Axios/Fetch）对 HTTP 错误和业务逻辑错误的处理机制分离，200 让前端仅需统一从 response.data 中处理业务结果 3. 穿透性强：微服务调用链（A→B→C）中，200 更易携带完整 JSON 错误体透传至上层，而 HTTP 错误码易被中间层框架吞没 / 改写

#### 标准响应体结构的示例：{“success”:true,“code”:“010010001,“msg”:“success”,“data”:null,userMsg:“用户操作成功”,devMsg:“用户操作成功”,solution:“请联系管理员”,traceId:“1234567890”},userMsg:用户提示信息，面向用户；devMsg:开发人员提示信息，面向开发人员，用于系统排查问题的，生产环境建议关闭，从而脱敏；solution:建议的操作；traceId:调用链追踪ID，分布式链路追踪；当然还可以定义其他的内容，或者减少部分内容，按需配置就行

一般来说，如果使用了msg，那么就不需要userMsg了和devMsg了，反之使用了userMsg和devMsg，那么就不需要msg了

#### 一般来说对于标准的响应体，一般都是采用枚举类来定义异常，封装code和一些通用的message，并且会进行全局管理

#### 一般会将业务系统的异常分为2类，一种是业务异常，如余额不足，一种是系统异常，如数据库异常，空指针等等
 