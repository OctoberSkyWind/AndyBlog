# Python Base

## Python ENV

#### pip::pip 安装 requirements.txt 依赖： pip install -r requirements.txt

#### conda::conda关闭默认base激活

#### uv::uv创建虚拟环境

#### uv::windows下激活指定位置nv环境,powershell终端执行 安装目录\Script\Activate.ps1

#### uv::windows下激活指定位置nv环境cmdl终端执行 安装目录\Script\Activate.bat

## python 数据类型

#### int类型：Python 3 中整数类型只有 int，它支持任意精度，可表示极大整数，其取值范围受系统内存（物理内存 + 虚拟内存）限制。

##              

#### Python 中的相对路径主要是相对于程序的当前工作目录（CWD),当前工作目录是 Python 解释器在运行时所处的目录,load_dotenv("./.env")加载时，是指的当前工作目录下的.env文件


#### is 运算符用于判断两个变量是否指向内存中的同一个对象（即身份相同，本质是比较两个对象的 id() 返回值是否相等），该运算符仅关注对象的内存地址，不涉及值的比较，即便两个对象的值完全一致但内存地址不同，is 也会返回 False；而 isinstance() 函数用于判断一个对象是否是指定类（或其子类）的实例（即类型匹配，天然支持继承关系），isinstance() 的第二个参数不仅可以是单个类，还可以是由多个类（或抽象基类）组成的元组，用于检查对象是否为元组中任意一个类（或抽象基类）的实例，该函数仅关注对象的类型层级关系，不涉及内存地址的比较。
#### Python 变量查找的完整底层逻辑分为编译时分析和运行时查找两个阶段，其核心矛盾在于静态作用域判定与动态命名空间访问的结合。编译阶段，解释器对函数体进行静态扫描，依据赋值即本地化原则：若名称在函数内任何位置被赋值（包括 =、+= 或作为 for 目标等），则整个函数内该名称均被标记为局部变量，并分配固定的局部变量槽位，生成对应的 LOAD_FAST（局部加载）或 STORE_FAST（局部存储）字节码指令；若名称仅被读取而未在函数内赋值，则根据其出现位置生成 LOAD_GLOBAL（全局 / 内置加载）或 LOAD_CLOSURE+LOAD_DEREF（闭包加载）指令。此阶段的作用域绑定是不可逆的 —— 一旦被标记为局部变量，即使该变量在运行时尚未赋值，解释器也绝不会沿 LEGB 链向上查找。运行阶段，解释器执行预编译的字节码：对于 LOAD_FAST 指令，直接访问局部变量数组的相应槽位，若槽位未初始化（对应变量未赋值），则抛出 UnboundLocalError；对于 LOAD_GLOBAL 指令，依次查找当前模块的全局命名空间字典和内置命名空间（builtins）字典，查找失败则抛出 NameError；对于闭包场景的 LOAD_DEREF 指令，先通过 LOAD_CLOSURE 加载闭包单元格对象，再通过 LOAD_DEREF 间接访问外层函数的非局部变量。此过程严格遵循编译时确定的查找路径，不存在运行时根据赋值语句位置动态调整作用域的逻辑。因此，在函数内任何位置对变量赋值都会导致该变量在整个函数作用域内被静态绑定为局部变量，即使赋值语句位于访问语句之后。这种设计确保了查找效率（局部变量通过数组索引直接访问，远快于字典的键查找）和语义一致性，但要求开发者通过 global 或 nonlocal 关键字显式声明对外层全局 / 非局部变量的修改意图，从而避免因隐式作用域切换导致的意外赋值或查找错误。

#### 对于可变对象，*= 调用原地修改方法实现对象内容的原地更新，变量地址保持不变，而 a = a * 2 会先计算生成新对象，再将变量重新指向新对象，地址发生改变；对于不可变对象，因无原地修改能力，*= 会退化为与 a = a * 2 相同的逻辑（均创建新对象），仅元组因 Python 底层优化，空 / 单元素元组的*=会呈现地址不变的表象，不改变不可变对象的核心特性。
## python 函数

#### print() 有 5 个主要参数，其中第一个 *objects 是可变参数

#### print() 函数默认使用空格分隔多个参数，但可以通过 sep 参数自定义分隔符

#### _xxx（单下划线：约定俗成（非语法），标识「内部使用」，提示开发者勿外部调用,可直接访问（不推荐）

#### \_\_xxx__（前后双下划线）:内置魔法方法,实现类的特殊功能（如构造、格式化等）,可直接访问，通常通过内置函数间接调用（如str(obj)等价于obj.\_\_str__()）

#### __xxx（双下划线）:语法特性（名称改写,直接访问访问不到，可以通过改写后的名称访问）,避免子类覆盖、实现真正封装，无法直接访问，可通过_类名__xxx访问（不推荐）

#### 对象判断布尔真假规则本质，优先调用__bool__(self)，未定义__bool__()，则调用__len__(self) 兜底，两者均未定义，对象默认恒为 True

#### \_\_eq__ 方法就是 == 相等运算符的底层实现逻辑，可以类比java中的equals方进行理解

#### \_\_repr__ 于返回对象无歧义、可精准重建的字符串表示，专供开发者调试与交互式环境使用；print(对象) 默认调用__str__，若类未定义__str__，会自动兜底调用__repr__ 替代,除此之外，在终端 / IDLE/PyCharm 控制台直接输入对象名回车，会无条件调用__repr__ 展示结果，当对象作为 列表、元组、字典、集合 等容器的元素时，打印 / 查看容器，容器内所有元素都会统一调用自身的__repr__（哪怕元素定义了__str__也无效）。

#### __new__是 Python 类的静态方法，首参为类本身cls，核心职责是分配内存、创建空白实例对象，是实例的 “创造者”，必须返回一个实例对象（返回有效实例才会触发后续流程，无返回则实例创建失败），可控制实例的创建规则（如单例模式、限制实例数量）__init__是实例方法，首参为new创建的实例self，核心职责是为空白实例绑定属性、赋值初始值，是实例的 “初始化器”，强制无返回值（仅能返回 None，写 return 会抛异常）；二者是 Python 实例化的绑定执行流程，new优先执行，创建实例后自动将其传给init的self并触发init执行，共同完成实例的完整生成，核心区别在于new操作类、管控创建过程、必须有返回值，init操作已存在的实例、仅做初始化、无返回值，new用于特殊的实例创建管控场景，init是日常自定义类绑定属性的标配。

#### mul 用于定义普通乘法 * 运算，执行时返回新对象且绝不会修改原对象；imul 用于定义原地乘法 = 运算，优先被*=调用，通常由列表（list）这类可变对象实现，逻辑是直接修改原对象的内部数据并返回自身，以此实现原地优化；对于整数（int）、字符串（str）这类不可变对象，其本身无法被原地修改，因此不会实现__imul__，当对不可变对象执行= 时，会自动退化为调用__mul__创建新对象，再将新对象重新赋值给原变量，二者的设计分别适配了 Python 中不可变对象的创建性运算、可变对象的原地优化运算逻辑，且 *= 始终优先尝试调用__imul__，未实现时才降级使用__mul__完成运算。

#### Python 中所有参数传递都是 “按对象引用传递” ，传递的是对象的引用（内存地址） ，对于不可变对象，函数内修改会创建新对象，不影响外部 ，对于可变对象，函数内修改会影响外部

#### Python 的内建作用域在底层由 builtins 模块实现，该模块定义了所有内置函数、异常与常量。代码中可直接访问 len、print 等内置名称，是因为解释器会遵循 LEGB 作用域查找链，自动向内建作用域（即 builtins 模块）查找实现。builtins 模块属于 CPython 解释器的实现细节，虽归 Python 标准库且可显式导入，但开发者通常无需直接依赖它，仅在需要修改或扩展内置行为时才考虑使用。在全局作用域中，主模块会以 __builtins__ 作为内建作用域的引用（直接指向 builtins 模块对象），非主模块的 __builtins__ 则多为 builtins 模块的 __dict__ 属性；局部作用域的名称查找严格遵循 LEGB 规则，逐级向上直至内建作用域，而不依赖 __builtins__ 属性。CPython 解释器可能在优化场景下缓存内建作用域的引用，以提升局部作用域的名称查找效率，这一行为属于解释器内部实现细节，无明确规范约束，也无法保证跨 Python 版本或跨解释器（如 PyPy、Jython）的兼容性，开发者绝对不应依赖此类细节进行编码。
## python 容器

#### list中list.sort() 是列表的原地排序方法，会直接修改原列表；sorted(list) 是内置函数，内部会先复制原列表，然后对新列表进行排序，最后返回这个新列表，即不改变原列表

## 生成器

#### 生成器是定义中包含 yield 的函数，调用该函数并不会执行函数体，而是直接获得一个生成器实例（可以看成允许多次暂停、恢复的特殊的函数一次调用）；生成器执行时遇到 yield 会暂停并返回其后的值，next ()（等价于 send (None)）或 send () 可让其恢复执行，直到函数体执行完毕（生成器耗尽）；生成器的迭代本质是遍历多次 yield 返回的值，恢复执行时 yield 表达式会接收值 ——send () 可传入具体值，而 next () 仅传入 None，直至生成器最终耗尽。

#### @contextmanager 装饰器将生成器函数转换为上下文管理器：yield 语句首次执行前的代码等价于上下文管理器的__enter__ 方法（进入上下文时执行）；yield 语句产生的首个值，是 with ... as 语句中 as 后变量接收的值（无返回值时可仅写 yield）；yield 语句首次执行后的所有代码（包括多轮 yield 后续逻辑）等价于上下文管理器的__exit__ 方法（退出上下文时执行）。需要注意的是，@contextmanager 封装的上下文管理器仅会执行到生成器的首个 yield，后续多轮 yield 不会被触发（若生成器包含多轮 yield，超出首个 yield 的逻辑需通过其他方式触发，并非上下文管理器的默认行为）。

#### 通过 yield 关键字将遍历逻辑封装为生成器，调用时不会一次性生成并返回所有遍历结果，而是以 “执行到 yield 处返回一个值并暂停 → 等待下一次请求再恢复执行” 的方式，实现可暂停、可恢复的可控遍历。

```python
def square_generator(numbers):
    """一个生成数字平方的生成器函数"""
    for num in numbers:
        # 遇到yield，返回当前值的平方，然后函数在此暂停
        yield num * num
        # 当生成器的__next__()被再次调用时，从这里恢复执行

# 创建一个生成器对象
my_numbers = [1, 2, 3, 4, 5]
squares = square_generator(my_numbers)

# 第一次调用next()，函数执行到第一个yield处暂停
print(next(squares))  # 输出: 1

# 第二次调用next()，函数从上次暂停处恢复，执行循环的下一次迭代，到yield处再次暂停
print(next(squares))  # 输出: 4

# 第三次调用next()
print(next(squares))  # 输出: 9

# 生成器也可以用在for循环中，for循环会自动处理next()和StopIteration
print("使用for循环遍历剩余的值:")
for value in squares: # 注意：此时生成器内部已经执行到第4个元素
    print(value)
# 输出:
# 16
# 25

```

## 类
#### 给单个类的实例添加实例属性仅影响该对象本身，新创建的同类实例不会拥有该属性；给类添加属性会让所有现有和未来的实例共享访问该属性；若类定义了可变类型的类属性，未为该属性定义同名实例属性的实例，对该属性做内部可变数据的修改操作（非整体重新赋值），会直接修改类本身的该类属性，进而影响其他所有未为该属性单独定义同名实例属性的同类实例；若对该属性整体重新赋值，则是为当前实例新增同名的实例属性，此后该实例访问该名称的属性时会优先使用自身的实例属性，且该赋值操作不会修改类属性；给单个实例动态绑定实例方法时，需通过 MethodType 将方法与实例绑定（否则调用会因缺少 self 参数报错），该方法仅对该实例生效，同类其他实例及类本身不会拥有该方法；给类动态绑定方法（实例方法 / 类方法 / 静态方法），则所有现有和未来的同类实例都会共享该方法，调用时遵循对应方法的原生规则（实例方法由实例调用、自动传实例为第一个参数，类方法由类或实例调用、自动传类为第一个参数，静态方法无自动传参、类和实例均可调用）。

#### Python 中自定义的实例方法、类方法、静态方法，底层实现均基于普通函数，其功能差异的核心体现在隐式参数的自动绑定机制上：三类方法的参数绑定逻辑由描述符协议结合解释器的方法调用规则、函数对象的特殊属性共同实现，其中实例方法会自动绑定代表实例的 self 隐式参数，以实现对象级操作；类方法经 @classmethod 装饰后会生成类方法描述符对象，自动绑定代表类的 cls 隐式参数，以实现类级操作；静态方法经 @staticmethod 装饰后会生成静态方法描述符对象，该描述符的实现逻辑会屏蔽隐式参数的自动绑定规则，调用时会忽略实例或类的绑定信息、直接以原函数的形式执行调用，不会为其自动绑定 self、cls 这类隐式参数，仅接收开发者显式传入的参数。这种设计让方法调用具备极高的灵活性 —— 无论是通过实例、类名调用，还是手动传递参数直接调用方法对应的底层函数本身，核心逻辑均围绕参数列表的匹配展开，只需保证实际入参与方法的形式参数要求一致即可；而 Python 内置类型的底层多由 C 语言实现，其对外暴露的方法并非基于 Python 普通函数构建，也未在 Python 层面实现描述符协议，但这些方法对外呈现的调用方式、隐式参数的自动绑定规则，仍严格遵循 Python 统一的语法与调用逻辑规范。

#### Python 多态的核心原理是运行时动态方法绑定，调用同名方法时，解释器会根据对象的实际类型，按「自身类→父类继承链」的固定查找顺序搜索该方法：单继承时顺次向上追溯，多继承时遵循 MRO（方法解析顺序）—— 由 C3 算法实现的从左到右、深度优先且避免重复的规则追溯，找到即执行对应实现，未找到则抛出属性异常；Python 依托鸭子类型实现了无显式接口声明、无需严格继承关系的弱类型多态，无需提前声明对象的类型，只要某对象在自身或其继承链中拥有匹配的属性 / 方法（仅要求方法名一致，无严格的参数签名强制匹配要求，仅会在调用传参时做基础的参数个数、位置与关键字参数的合法性校验），就能被统一的接口调用，而不同类型的对象会因自身类或继承链中的方法实现不同，在统一调用中执行差异化的行为，最终实现 “一个接口，多种实现” 的多态核心效果，这也是 Python 多态灵活性的关键体现。

## 类型注解

#### Python中类型注解与实际的属性值实际赋值不要求一致，只是一种提示作用，编译器完全允许，仅静态检查工具（如mypy）会根据注解进行类型检查，如Pydantic/SQlAlchemy等都利用了这种类型注解的特性（仅为注释，无实际效果），然后提供对应的如mypy插件，让静态工具可以识别，从而不报错

## 常用类

#### Queue::get() 从队列取出数据（物理操作），而task_done() 和 join() 的操作对象都是内部计数器，分别是减少内部计数器（逻辑标记）和检查计数器是否归零（同步等待）_

## 异常

#### Python 所有异常或错误均直接或间接继承 BaseException，无 Java 的 Exception/Error 划分，工程上绝大多数场景禁止 except: / except BaseException捕获所有异常，工程开发中，99% 的业务场景只需捕获 Exception；BaseException 的其他直接子类，属于「不应被业务代码捕获」的范畴。

## 模块、包
#### Python 中模块导入的命名与访问遵循这些约定和规则：单下划线前缀的名称是约定俗成的 “内部使用” 标识，虽能被外部导入和使用，但官方明确不推荐外部直接使用；双下划线前缀的名称仅在类中会触发 Python 的名称改写（name mangling）机制，外部无法直接通过原名称访问，需使用类名拼接改写后的名称（格式为_类名__原名称）才能访问，模块级的双下划线名称不会触发该机制，其中模块内以双下划线开头且结尾的是系统保留的特殊名称（如__init__、name），非该类型的模块级双下划线前缀名称可被外部正常导入和访问；使用 import * 导入模块时，会默认排除所有单下划线开头的名称，模块级非系统保留的双下划线开头的名称也不会被排除，若需让单下划线开头的名称被 import * 导入，需将其在模块的__all__列表中显式声明，同时__all__会严格限定 import * 的导入范围，无论名称是否以下划线开头，未在__all__中的名称都会被排除，且__all__仅对 import * 这种导入方式生效，对直接导入、别名导入、from 模块 import 名称等普通导入方式无任何限制作用。

#### Python 导入包的核心逻辑为：包是承载模块 / 子包的文件夹，Python 3.3+ 原生支持无 init.py 的命名空间包，所有 Python 版本均兼容有 init.py 的常规包；命名空间包仅作为模块 / 子包的层级访问入口，无独立的可执行逻辑，单独导入无实际功能，常规包是日常开发的首选，导入常规包的本质就是执行其根目录下的 init.py 文件，导入后可直接访问该文件中定义、导入或显式导出的内容；无论常规包还是命名空间包，导入包本身都不会自动加载其内部的子模块 / 子包，需通过「包名.子模块」的方式直接访问，或通过 from 包 import 子模块 的语法手动导入后才能使用；而 from 包 import * 的导入方式仅对常规包生效，该操作的导入范围完全由包的 init.py 文件决定 —— 定义 all 列表时按列表显式限定导入范围，未定义 all 时则导入该文件中定义或显式导入的非单下划线开头的公开名称，对命名空间包执行该语句会直接触发 ImportError 异常，并非无内容导入的空操作。